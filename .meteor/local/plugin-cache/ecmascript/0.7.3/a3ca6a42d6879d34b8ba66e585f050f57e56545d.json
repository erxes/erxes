{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mongo/allow_tests.js","filenameRelative":"/packages/mongo/allow_tests.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mongo/allow_tests.js.map","sourceFileName":"/packages/mongo/allow_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"allow_tests"},"ignored":false,"code":"if (Meteor.isServer) {\n  // Set up allow/deny rules for test collections\n  var allowCollections = {}; // We create the collections in the publisher (instead of using a method or\n  // something) because if we made them with a method, we'd need to follow the\n  // method with some subscribes, and it's possible that the method call would\n  // be delayed by a wait method and the subscribe messages would be sent before\n  // it and fail due to the collection not yet existing. So we are very hacky\n  // and use a publish.\n\n  Meteor.publish(\"allowTests\", function (nonce, idGeneration) {\n    check(nonce, String);\n    check(idGeneration, String);\n    var cursors = [];\n    var needToConfigure; // helper for defining a collection. we are careful to create just one\n    // Mongo.Collection even if the sub body is rerun, by caching them.\n\n    var defineCollection = function (name, insecure, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection;\n\n      if (_.has(allowCollections, fullName)) {\n        collection = allowCollections[fullName];\n        if (needToConfigure === true) throw new Error(\"collections inconsistently exist\");\n        needToConfigure = false;\n      } else {\n        collection = new Mongo.Collection(fullName, {\n          idGeneration: idGeneration,\n          transform: transform\n        });\n        allowCollections[fullName] = collection;\n        if (needToConfigure === false) throw new Error(\"collections inconsistently don't exist\");\n        needToConfigure = true;\n        collection._insecure = insecure;\n        var m = {};\n\n        m[\"clear-collection-\" + fullName] = function () {\n          collection.remove({});\n        };\n\n        Meteor.methods(m);\n      }\n\n      cursors.push(collection.find());\n      return collection;\n    };\n\n    var insecureCollection = defineCollection(\"collection-insecure\", true /*insecure*/); // totally locked down collection\n\n    var lockedDownCollection = defineCollection(\"collection-locked-down\", false /*insecure*/); // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n\n    var restrictedCollectionDefaultSecure = defineCollection(\"collection-restrictedDefaultSecure\", false /*insecure*/);\n    var restrictedCollectionDefaultInsecure = defineCollection(\"collection-restrictedDefaultInsecure\", true /*insecure*/);\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\"collection-restrictedForUpdateOptionsTest\", true /*insecure*/);\n    var restrictedCollectionForPartialAllowTest = defineCollection(\"collection-restrictedForPartialAllowTest\", true /*insecure*/);\n    var restrictedCollectionForPartialDenyTest = defineCollection(\"collection-restrictedForPartialDenyTest\", true /*insecure*/);\n    var restrictedCollectionForFetchTest = defineCollection(\"collection-restrictedForFetchTest\", true /*insecure*/);\n    var restrictedCollectionForFetchAllTest = defineCollection(\"collection-restrictedForFetchAllTest\", true /*insecure*/);\n    var restrictedCollectionWithTransform = defineCollection(\"withTransform\", false, function (doc) {\n      return doc.a;\n    });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\"collection-restrictedForInvalidTransform\", false /*insecure*/);\n    var restrictedCollectionForClientIdTest = defineCollection(\"collection-restrictedForClientIdTest\", false /*insecure*/);\n\n    if (needToConfigure) {\n      restrictedCollectionWithTransform.allow({\n        insert: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        update: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        remove: function (userId, doc) {\n          return doc.bar === \"bar\";\n        }\n      });\n      restrictedCollectionWithTransform.allow({\n        // transform: null means that doc here is the top level, not the 'a'\n        // element.\n        transform: null,\n        insert: function (userId, doc) {\n          return !!doc.topLevelField;\n        },\n        update: function (userId, doc) {\n          return !!doc.topLevelField;\n        }\n      });\n      restrictedCollectionForInvalidTransformTest.allow({\n        // transform must return an object which is not a mongo id\n        transform: function (doc) {\n          return doc._id;\n        },\n        insert: function () {\n          return true;\n        }\n      });\n      restrictedCollectionForClientIdTest.allow({\n        // This test just requires the collection to trigger the restricted\n        // case.\n        insert: function () {\n          return true;\n        }\n      }); // two calls to allow to verify that either validator is sufficient.\n\n      var allows = [{\n        insert: function (userId, doc) {\n          return doc.canInsert;\n        },\n        update: function (userId, doc) {\n          return doc.canUpdate;\n        },\n        remove: function (userId, doc) {\n          return doc.canRemove;\n        }\n      }, {\n        insert: function (userId, doc) {\n          return doc.canInsert2;\n        },\n        update: function (userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'canUpdate2');\n        },\n        remove: function (userId, doc) {\n          return doc.canRemove2;\n        }\n      }]; // two calls to deny to verify that either one blocks the change.\n\n      var denies = [{\n        insert: function (userId, doc) {\n          return doc.cantInsert;\n        },\n        remove: function (userId, doc) {\n          return doc.cantRemove;\n        }\n      }, {\n        insert: function (userId, doc) {\n          // Don't allow explicit ID to be set by the client.\n          return _.has(doc, '_id');\n        },\n        update: function (userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'verySecret');\n        }\n      }];\n\n      _.each([restrictedCollectionDefaultSecure, restrictedCollectionDefaultInsecure, restrictedCollectionForUpdateOptionsTest], function (collection) {\n        _.each(allows, function (allow) {\n          collection.allow(allow);\n        });\n\n        _.each(denies, function (deny) {\n          collection.deny(deny);\n        });\n      }); // just restrict one operation so that we can verify that others\n      // fail\n\n\n      restrictedCollectionForPartialAllowTest.allow({\n        insert: function () {}\n      });\n      restrictedCollectionForPartialDenyTest.deny({\n        insert: function () {}\n      }); // verify that we only fetch the fields specified - we should\n      // be fetching just field1, field2, and field3.\n\n      restrictedCollectionForFetchTest.allow({\n        insert: function () {\n          return true;\n        },\n        update: function (userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function (userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchTest.allow({\n        fetch: ['field2']\n      });\n      restrictedCollectionForFetchTest.deny({\n        fetch: ['field3']\n      }); // verify that not passing fetch to one of the calls to allow\n      // causes all fields to be fetched\n\n      restrictedCollectionForFetchAllTest.allow({\n        insert: function () {\n          return true;\n        },\n        update: function (userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function (userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchAllTest.allow({\n        update: function () {\n          return true;\n        }\n      });\n    }\n\n    return cursors;\n  });\n}\n\nif (Meteor.isClient) {\n  _.each(['STRING', 'MONGO'], function (idGeneration) {\n    // Set up a bunch of test collections... on the client! They match the ones\n    // created by setUpAllowTestsCollections.\n    var nonce = Random.id(); // Tell the server to make, configure, and publish a set of collections unique\n    // to our test run. Since the method does not unblock, this will complete\n    // running on the server before anything else happens.\n\n    Meteor.subscribe('allowTests', nonce, idGeneration); // helper for defining a collection, subscribing to it, and defining\n    // a method to clear it\n\n    var defineCollection = function (name, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection = new Mongo.Collection(fullName, {\n        idGeneration: idGeneration,\n        transform: transform\n      });\n\n      collection.callClearMethod = function (callback) {\n        Meteor.call(\"clear-collection-\" + fullName, callback);\n      };\n\n      collection.unnoncedName = name + idGeneration;\n      return collection;\n    }; // totally insecure collection\n\n\n    var insecureCollection = defineCollection(\"collection-insecure\"); // totally locked down collection\n\n    var lockedDownCollection = defineCollection(\"collection-locked-down\"); // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n\n    var restrictedCollectionDefaultSecure = defineCollection(\"collection-restrictedDefaultSecure\");\n    var restrictedCollectionDefaultInsecure = defineCollection(\"collection-restrictedDefaultInsecure\");\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\"collection-restrictedForUpdateOptionsTest\");\n    var restrictedCollectionForPartialAllowTest = defineCollection(\"collection-restrictedForPartialAllowTest\");\n    var restrictedCollectionForPartialDenyTest = defineCollection(\"collection-restrictedForPartialDenyTest\");\n    var restrictedCollectionForFetchTest = defineCollection(\"collection-restrictedForFetchTest\");\n    var restrictedCollectionForFetchAllTest = defineCollection(\"collection-restrictedForFetchAllTest\");\n    var restrictedCollectionWithTransform = defineCollection(\"withTransform\", function (doc) {\n      return doc.a;\n    });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\"collection-restrictedForInvalidTransform\");\n    var restrictedCollectionForClientIdTest = defineCollection(\"collection-restrictedForClientIdTest\"); // test that if allow is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n\n    testAsyncMulti(\"collection - partial allow, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForPartialAllowTest.update('foo', {\n        $set: {\n          updated: true\n        }\n      }, expect(function (err, res) {\n        test.equal(err.error, 403);\n      }));\n    }]); // test that if deny is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n\n    testAsyncMulti(\"collection - partial deny, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForPartialDenyTest.update('foo', {\n        $set: {\n          updated: true\n        }\n      }, expect(function (err, res) {\n        test.equal(err.error, 403);\n      }));\n    }]); // test that we only fetch the fields specified\n\n    testAsyncMulti(\"collection - fetch, \" + idGeneration, [function (test, expect) {\n      var fetchId = restrictedCollectionForFetchTest.insert({\n        field1: 1,\n        field2: 1,\n        field3: 1,\n        field4: 1\n      });\n      var fetchAllId = restrictedCollectionForFetchAllTest.insert({\n        field1: 1,\n        field2: 1,\n        field3: 1,\n        field4: 1\n      });\n      restrictedCollectionForFetchTest.update(fetchId, {\n        $set: {\n          updated: true\n        }\n      }, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3\");\n      }));\n      restrictedCollectionForFetchTest.remove(fetchId, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3\");\n      }));\n      restrictedCollectionForFetchAllTest.update(fetchAllId, {\n        $set: {\n          updated: true\n        }\n      }, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n      }));\n      restrictedCollectionForFetchAllTest.remove(fetchAllId, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n      }));\n    }]);\n\n    (function () {\n      testAsyncMulti(\"collection - restricted factories \" + idGeneration, [function (test, expect) {\n        restrictedCollectionWithTransform.callClearMethod(expect(function () {\n          test.equal(restrictedCollectionWithTransform.find().count(), 0);\n        }));\n      }, function (test, expect) {\n        var self = this;\n        restrictedCollectionWithTransform.insert({\n          a: {\n            foo: \"foo\",\n            bar: \"bar\",\n            baz: \"baz\"\n          }\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item1 = res;\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: {\n            foo: \"foo\",\n            bar: \"quux\",\n            baz: \"quux\"\n          },\n          b: \"potato\"\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item2 = res;\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: {\n            foo: \"adsfadf\",\n            bar: \"quux\",\n            baz: \"quux\"\n          },\n          b: \"potato\"\n        }, expect(function (e, res) {\n          test.isTrue(e);\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: {\n            foo: \"bar\"\n          },\n          topLevelField: true\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item3 = res;\n        }));\n      }, function (test, expect) {\n        var self = this; // This should work, because there is an update allow for things with\n        // topLevelField.\n\n        restrictedCollectionWithTransform.update(self.item3, {\n          $set: {\n            xxx: true\n          }\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.equal(1, res);\n        }));\n      }, function (test, expect) {\n        var self = this;\n        test.equal(restrictedCollectionWithTransform.findOne(self.item1), {\n          _id: self.item1,\n          foo: \"foo\",\n          bar: \"bar\",\n          baz: \"baz\"\n        });\n        restrictedCollectionWithTransform.remove(self.item1, expect(function (e, res) {\n          test.isFalse(e);\n        }));\n        restrictedCollectionWithTransform.remove(self.item2, expect(function (e, res) {\n          test.isTrue(e);\n        }));\n      }]);\n    })();\n\n    testAsyncMulti(\"collection - insecure, \" + idGeneration, [function (test, expect) {\n      insecureCollection.callClearMethod(expect(function () {\n        test.equal(insecureCollection.find().count(), 0);\n      }));\n    }, function (test, expect) {\n      var id = insecureCollection.insert({\n        foo: 'bar'\n      }, expect(function (err, res) {\n        test.equal(res, id);\n        test.equal(insecureCollection.find(id).count(), 1);\n        test.equal(insecureCollection.findOne(id).foo, 'bar');\n      }));\n      test.equal(insecureCollection.find(id).count(), 1);\n      test.equal(insecureCollection.findOne(id).foo, 'bar');\n    }]);\n    testAsyncMulti(\"collection - locked down, \" + idGeneration, [function (test, expect) {\n      lockedDownCollection.callClearMethod(expect(function () {\n        test.equal(lockedDownCollection.find().count(), 0);\n      }));\n    }, function (test, expect) {\n      lockedDownCollection.insert({\n        foo: 'bar'\n      }, expect(function (err, res) {\n        test.equal(err.error, 403);\n        test.equal(lockedDownCollection.find().count(), 0);\n      }));\n    }]);\n\n    (function () {\n      var collection = restrictedCollectionForUpdateOptionsTest;\n      var id1, id2;\n      testAsyncMulti(\"collection - update options, \" + idGeneration, [// init\n      function (test, expect) {\n        collection.callClearMethod(expect(function () {\n          test.equal(collection.find().count(), 0);\n        }));\n      }, // put a few objects\n      function (test, expect) {\n        var doc = {\n          canInsert: true,\n          canUpdate: true\n        };\n        id1 = collection.insert(doc);\n        id2 = collection.insert(doc);\n        collection.insert(doc);\n        collection.insert(doc, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 4);\n        }));\n      }, // update by id\n      function (test, expect) {\n        collection.update(id1, {\n          $set: {\n            updated: true\n          }\n        }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({\n            updated: true\n          }).count(), 1);\n        }));\n      }, // update by id in an object\n      function (test, expect) {\n        collection.update({\n          _id: id2\n        }, {\n          $set: {\n            updated: true\n          }\n        }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({\n            updated: true\n          }).count(), 2);\n        }));\n      }, // update with replacement operator not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({\n          _id: id2\n        }, {\n          _id: id2,\n          updated: true\n        }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /In a restricted/); // unchanged\n\n          test.equal(collection.find({\n            updated: true\n          }).count(), 2);\n        }));\n      }, // upsert not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({\n          _id: id2\n        }, {\n          $set: {\n            upserted: true\n          }\n        }, {\n          upsert: true\n        }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /in a restricted/);\n          test.equal(collection.find({\n            upserted: true\n          }).count(), 0);\n        }));\n      }, // update with rename operator not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({\n          _id: id2\n        }, {\n          $rename: {\n            updated: 'asdf'\n          }\n        }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /not allowed/); // unchanged\n\n          test.equal(collection.find({\n            updated: true\n          }).count(), 2);\n        }));\n      }, // update method with a non-ID selector is not allowed\n      function (test, expect) {\n        // We shouldn't even send the method...\n        test.throws(function () {\n          collection.update({\n            updated: {\n              $exists: false\n            }\n          }, {\n            $set: {\n              updated: true\n            }\n          });\n        }); // ... but if we did, the server would reject it too.\n\n        Meteor.call('/' + collection._name + '/update', {\n          updated: {\n            $exists: false\n          }\n        }, {\n          $set: {\n            updated: true\n          }\n        }, expect(function (err, res) {\n          test.equal(err.error, 403); // unchanged\n\n          test.equal(collection.find({\n            updated: true\n          }).count(), 2);\n        }));\n      }, // make sure it doesn't think that {_id: 'foo', something: else} is ok.\n      function (test, expect) {\n        test.throws(function () {\n          collection.update({\n            _id: id1,\n            updated: {\n              $exists: false\n            }\n          }, {\n            $set: {\n              updated: true\n            }\n          });\n        });\n      }, // remove method with a non-ID selector is not allowed\n      function (test, expect) {\n        // We shouldn't even send the method...\n        test.throws(function () {\n          collection.remove({\n            updated: true\n          });\n        }); // ... but if we did, the server would reject it too.\n\n        Meteor.call('/' + collection._name + '/remove', {\n          updated: true\n        }, expect(function (err, res) {\n          test.equal(err.error, 403); // unchanged\n\n          test.equal(collection.find({\n            updated: true\n          }).count(), 2);\n        }));\n      }]);\n    })();\n\n    _.each([restrictedCollectionDefaultInsecure, restrictedCollectionDefaultSecure], function (collection) {\n      var canUpdateId, canRemoveId;\n      testAsyncMulti(\"collection - \" + collection.unnoncedName, [// init\n      function (test, expect) {\n        collection.callClearMethod(expect(function () {\n          test.equal(collection.find().count(), 0);\n        }));\n      }, // insert with no allows passing. request is denied.\n      function (test, expect) {\n        collection.insert({}, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      }, // insert with one allow and one deny. denied.\n      function (test, expect) {\n        collection.insert({\n          canInsert: true,\n          cantInsert: true\n        }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      }, // insert with one allow and other deny. denied.\n      function (test, expect) {\n        collection.insert({\n          canInsert: true,\n          _id: Random.id()\n        }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      }, // insert one allow passes. allowed.\n      function (test, expect) {\n        collection.insert({\n          canInsert: true\n        }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 1);\n        }));\n      }, // insert other allow passes. allowed.\n      // includes canUpdate for later.\n      function (test, expect) {\n        canUpdateId = collection.insert({\n          canInsert2: true,\n          canUpdate: true\n        }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 2);\n        }));\n      }, // yet a third insert executes. this one has canRemove and\n      // cantRemove set for later.\n      function (test, expect) {\n        canRemoveId = collection.insert({\n          canInsert: true,\n          canRemove: true,\n          cantRemove: true\n        }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 3);\n        }));\n      }, // can't update with a non-operator mutation\n      function (test, expect) {\n        collection.update(canUpdateId, {\n          newObject: 1\n        }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 3);\n        }));\n      }, // updating dotted fields works as if we are changing their\n      // top part\n      function (test, expect) {\n        collection.update(canUpdateId, {\n          $set: {\n            \"dotted.field\": 1\n          }\n        }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.findOne(canUpdateId).dotted.field, 1);\n        }));\n      }, function (test, expect) {\n        collection.update(canUpdateId, {\n          $set: {\n            \"verySecret.field\": 1\n          }\n        }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find({\n            verySecret: {\n              $exists: true\n            }\n          }).count(), 0);\n        }));\n      }, // update doesn't do anything if no docs match\n      function (test, expect) {\n        collection.update(\"doesn't exist\", {\n          $set: {\n            updated: true\n          }\n        }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 0); // nothing has changed\n\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({\n            updated: true\n          }).count(), 0);\n        }));\n      }, // update fails when access is denied trying to set `verySecret`\n      function (test, expect) {\n        collection.update(canUpdateId, {\n          $set: {\n            verySecret: true\n          }\n        }, expect(function (err, res) {\n          test.equal(err.error, 403); // nothing has changed\n\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({\n            updated: true\n          }).count(), 0);\n        }));\n      }, // update fails when trying to set two fields, one of which is\n      // `verySecret`\n      function (test, expect) {\n        collection.update(canUpdateId, {\n          $set: {\n            updated: true,\n            verySecret: true\n          }\n        }, expect(function (err, res) {\n          test.equal(err.error, 403); // nothing has changed\n\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({\n            updated: true\n          }).count(), 0);\n        }));\n      }, // update fails when trying to modify docs that don't\n      // have `canUpdate` set\n      function (test, expect) {\n        collection.update(canRemoveId, {\n          $set: {\n            updated: true\n          }\n        }, expect(function (err, res) {\n          test.equal(err.error, 403); // nothing has changed\n\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({\n            updated: true\n          }).count(), 0);\n        }));\n      }, // update executes when it should\n      function (test, expect) {\n        collection.update(canUpdateId, {\n          $set: {\n            updated: true\n          }\n        }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({\n            updated: true\n          }).count(), 1);\n        }));\n      }, // remove fails when trying to modify a doc with no `canRemove` set\n      function (test, expect) {\n        collection.remove(canUpdateId, expect(function (err, res) {\n          test.equal(err.error, 403); // nothing has changed\n\n          test.equal(collection.find().count(), 3);\n        }));\n      }, // remove fails when trying to modify an doc with `cantRemove`\n      // set\n      function (test, expect) {\n        collection.remove(canRemoveId, expect(function (err, res) {\n          test.equal(err.error, 403); // nothing has changed\n\n          test.equal(collection.find().count(), 3);\n        }));\n      }, // update the doc to remove cantRemove.\n      function (test, expect) {\n        collection.update(canRemoveId, {\n          $set: {\n            cantRemove: false,\n            canUpdate2: true\n          }\n        }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({\n            cantRemove: true\n          }).count(), 0);\n        }));\n      }, // now remove can remove it.\n      function (test, expect) {\n        collection.remove(canRemoveId, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1); // successfully removed\n\n          test.equal(collection.find().count(), 2);\n        }));\n      }, // try to remove a doc that doesn't exist. see we remove no docs.\n      function (test, expect) {\n        collection.remove('some-random-id-that-never-matches', expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 0); // nothing removed\n\n          test.equal(collection.find().count(), 2);\n        }));\n      }, // methods can still bypass restrictions\n      function (test, expect) {\n        collection.callClearMethod(expect(function (err, res) {\n          test.isFalse(err); // successfully removed\n\n          test.equal(collection.find().count(), 0);\n        }));\n      }]);\n    });\n\n    testAsyncMulti(\"collection - allow/deny transform must return object, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForInvalidTransformTest.insert({}, expect(function (err, res) {\n        test.isTrue(err);\n      }));\n    }]);\n    testAsyncMulti(\"collection - restricted collection allows client-side id, \" + idGeneration, [function (test, expect) {\n      var self = this;\n      self.id = Random.id();\n      restrictedCollectionForClientIdTest.insert({\n        _id: self.id\n      }, expect(function (err, res) {\n        test.isFalse(err);\n        test.equal(res, self.id);\n        test.equal(restrictedCollectionForClientIdTest.findOne(self.id), {\n          _id: self.id\n        });\n      }));\n    }]);\n  }); // end idGeneration loop\n\n} // end if isClient\n// A few simple server-only tests which don't need to coordinate collections\n// with the client..\n\n\nif (Meteor.isServer) {\n  Tinytest.add(\"collection - allow and deny validate options\", function (test) {\n    var collection = new Mongo.Collection(null);\n    test.throws(function () {\n      collection.allow({\n        invalidOption: true\n      });\n    });\n    test.throws(function () {\n      collection.deny({\n        invalidOption: true\n      });\n    });\n\n    _.each(['insert', 'update', 'remove', 'fetch'], function (key) {\n      var options = {};\n      options[key] = true;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = false;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = undefined;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = ['an array']; // this should be a function, not an array\n\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    test.throws(function () {\n      collection.allow({\n        fetch: function () {}\n      }); // this should be an array\n    });\n  });\n  Tinytest.add(\"collection - calling allow restricts\", function (test) {\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._restricted, false);\n    collection.allow({\n      insert: function () {}\n    });\n    test.equal(collection._restricted, true);\n  });\n  Tinytest.add(\"collection - global insecure\", function (test) {\n    // note: This test alters the global insecure status, by sneakily hacking\n    // the global Package object!\n    var insecurePackage = Package.insecure;\n    Package.insecure = {};\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._isInsecure(), true);\n    Package.insecure = undefined;\n    test.equal(collection._isInsecure(), false);\n    delete Package.insecure;\n    test.equal(collection._isInsecure(), false);\n    collection._insecure = true;\n    test.equal(collection._isInsecure(), true);\n    if (insecurePackage) Package.insecure = insecurePackage;else delete Package.insecure;\n  });\n}","map":{"version":3,"sources":["/packages/mongo/allow_tests.js"],"names":["Meteor","isServer","allowCollections","publish","nonce","idGeneration","check","String","cursors","needToConfigure","defineCollection","name","insecure","transform","fullName","collection","_","has","Error","Mongo","Collection","_insecure","m","remove","methods","push","find","insecureCollection","lockedDownCollection","restrictedCollectionDefaultSecure","restrictedCollectionDefaultInsecure","restrictedCollectionForUpdateOptionsTest","restrictedCollectionForPartialAllowTest","restrictedCollectionForPartialDenyTest","restrictedCollectionForFetchTest","restrictedCollectionForFetchAllTest","restrictedCollectionWithTransform","doc","a","restrictedCollectionForInvalidTransformTest","restrictedCollectionForClientIdTest","allow","insert","userId","foo","update","bar","topLevelField","_id","allows","canInsert","canUpdate","canRemove","canInsert2","fields","modifier","indexOf","canRemove2","denies","cantInsert","cantRemove","each","deny","keys","sort","join","fetch","isClient","Random","id","subscribe","callClearMethod","callback","call","unnoncedName","testAsyncMulti","test","expect","$set","updated","err","res","equal","error","fetchId","field1","field2","field3","field4","fetchAllId","reason","count","self","baz","e","isFalse","isTrue","item1","b","item2","item3","xxx","findOne","id1","id2","matches","upserted","upsert","$rename","throws","$exists","_name","canUpdateId","canRemoveId","newObject","dotted","field","verySecret","canUpdate2","Tinytest","add","invalidOption","key","options","undefined","_restricted","insecurePackage","Package","_isInsecure"],"mappings":"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","file":"/packages/mongo/allow_tests.js.map","sourcesContent":["if (Meteor.isServer) {\n  // Set up allow/deny rules for test collections\n\n  var allowCollections = {};\n\n  // We create the collections in the publisher (instead of using a method or\n  // something) because if we made them with a method, we'd need to follow the\n  // method with some subscribes, and it's possible that the method call would\n  // be delayed by a wait method and the subscribe messages would be sent before\n  // it and fail due to the collection not yet existing. So we are very hacky\n  // and use a publish.\n  Meteor.publish(\"allowTests\", function (nonce, idGeneration) {\n    check(nonce, String);\n    check(idGeneration, String);\n    var cursors = [];\n    var needToConfigure;\n\n    // helper for defining a collection. we are careful to create just one\n    // Mongo.Collection even if the sub body is rerun, by caching them.\n    var defineCollection = function(name, insecure, transform) {\n      var fullName = name + idGeneration + nonce;\n\n      var collection;\n      if (_.has(allowCollections, fullName)) {\n        collection = allowCollections[fullName];\n        if (needToConfigure === true)\n          throw new Error(\"collections inconsistently exist\");\n        needToConfigure = false;\n      } else {\n        collection = new Mongo.Collection(\n          fullName, {idGeneration: idGeneration, transform: transform});\n        allowCollections[fullName] = collection;\n        if (needToConfigure === false)\n          throw new Error(\"collections inconsistently don't exist\");\n        needToConfigure = true;\n        collection._insecure = insecure;\n        var m = {};\n        m[\"clear-collection-\" + fullName] = function() {\n          collection.remove({});\n        };\n        Meteor.methods(m);\n      }\n\n      cursors.push(collection.find());\n      return collection;\n    };\n\n    var insecureCollection = defineCollection(\n      \"collection-insecure\", true /*insecure*/);\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\n      \"collection-locked-down\", false /*insecure*/);\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\", false /*insecure*/);\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\", true /*insecure*/);\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\", true /*insecure*/);\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\", true /*insecure*/);\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\", true /*insecure*/);\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\", true /*insecure*/);\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\", true /*insecure*/);\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", false, function (doc) {\n        return doc.a;\n      });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\n      \"collection-restrictedForInvalidTransform\", false /*insecure*/);\n    var restrictedCollectionForClientIdTest = defineCollection(\n      \"collection-restrictedForClientIdTest\", false /*insecure*/);\n\n    if (needToConfigure) {\n      restrictedCollectionWithTransform.allow({\n        insert: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        update: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        remove: function (userId, doc) {\n          return doc.bar === \"bar\";\n        }\n      });\n      restrictedCollectionWithTransform.allow({\n        // transform: null means that doc here is the top level, not the 'a'\n        // element.\n        transform: null,\n        insert: function (userId, doc) {\n          return !!doc.topLevelField;\n        },\n        update: function (userId, doc) {\n          return !!doc.topLevelField;\n        }\n      });\n      restrictedCollectionForInvalidTransformTest.allow({\n        // transform must return an object which is not a mongo id\n        transform: function (doc) { return doc._id; },\n        insert: function () { return true; }\n      });\n      restrictedCollectionForClientIdTest.allow({\n        // This test just requires the collection to trigger the restricted\n        // case.\n        insert: function () { return true; }\n      });\n\n      // two calls to allow to verify that either validator is sufficient.\n      var allows = [{\n        insert: function(userId, doc) {\n          return doc.canInsert;\n        },\n        update: function(userId, doc) {\n          return doc.canUpdate;\n        },\n        remove: function (userId, doc) {\n          return doc.canRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          return doc.canInsert2;\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'canUpdate2');\n        },\n        remove: function(userId, doc) {\n          return doc.canRemove2;\n        }\n      }];\n\n      // two calls to deny to verify that either one blocks the change.\n      var denies = [{\n        insert: function(userId, doc) {\n          return doc.cantInsert;\n        },\n        remove: function (userId, doc) {\n          return doc.cantRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          // Don't allow explicit ID to be set by the client.\n          return _.has(doc, '_id');\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'verySecret');\n        }\n      }];\n\n      _.each([\n        restrictedCollectionDefaultSecure,\n        restrictedCollectionDefaultInsecure,\n        restrictedCollectionForUpdateOptionsTest\n      ], function (collection) {\n        _.each(allows, function (allow) {\n          collection.allow(allow);\n        });\n        _.each(denies, function (deny) {\n          collection.deny(deny);\n        });\n      });\n\n      // just restrict one operation so that we can verify that others\n      // fail\n      restrictedCollectionForPartialAllowTest.allow({\n        insert: function() {}\n      });\n      restrictedCollectionForPartialDenyTest.deny({\n        insert: function() {}\n      });\n\n      // verify that we only fetch the fields specified - we should\n      // be fetching just field1, field2, and field3.\n      restrictedCollectionForFetchTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchTest.allow({\n        fetch: ['field2']\n      });\n      restrictedCollectionForFetchTest.deny({\n        fetch: ['field3']\n      });\n\n      // verify that not passing fetch to one of the calls to allow\n      // causes all fields to be fetched\n      restrictedCollectionForFetchAllTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchAllTest.allow({\n        update: function() { return true; }\n      });\n    }\n\n    return cursors;\n  });\n}\n\nif (Meteor.isClient) {\n  _.each(['STRING', 'MONGO'], function (idGeneration) {\n    // Set up a bunch of test collections... on the client! They match the ones\n    // created by setUpAllowTestsCollections.\n\n    var nonce = Random.id();\n    // Tell the server to make, configure, and publish a set of collections unique\n    // to our test run. Since the method does not unblock, this will complete\n    // running on the server before anything else happens.\n    Meteor.subscribe('allowTests', nonce, idGeneration);\n\n    // helper for defining a collection, subscribing to it, and defining\n    // a method to clear it\n    var defineCollection = function(name, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection = new Mongo.Collection(\n        fullName, {idGeneration: idGeneration, transform: transform});\n\n      collection.callClearMethod = function (callback) {\n        Meteor.call(\"clear-collection-\" + fullName, callback);\n      };\n      collection.unnoncedName = name + idGeneration;\n      return collection;\n    };\n\n    // totally insecure collection\n    var insecureCollection = defineCollection(\"collection-insecure\");\n\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\");\n\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\");\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\");\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\");\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\");\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\");\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\");\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\");\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", function (doc) {\n        return doc.a;\n      });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\n      \"collection-restrictedForInvalidTransform\");\n    var restrictedCollectionForClientIdTest = defineCollection(\n      \"collection-restrictedForClientIdTest\");\n\n    // test that if allow is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial allow, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialAllowTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n    // test that if deny is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial deny, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialDenyTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n\n    // test that we only fetch the fields specified\n    testAsyncMulti(\"collection - fetch, \" + idGeneration, [\n      function (test, expect) {\n        var fetchId = restrictedCollectionForFetchTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        var fetchAllId = restrictedCollectionForFetchAllTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        restrictedCollectionForFetchTest.update(\n          fetchId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3\");\n          }));\n        restrictedCollectionForFetchTest.remove(\n          fetchId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3\");\n          }));\n\n        restrictedCollectionForFetchAllTest.update(\n          fetchAllId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n          }));\n        restrictedCollectionForFetchAllTest.remove(\n          fetchAllId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n          }));\n      }\n    ]);\n\n    (function(){\n      testAsyncMulti(\"collection - restricted factories \" + idGeneration, [\n        function (test, expect) {\n          restrictedCollectionWithTransform.callClearMethod(expect(function () {\n            test.equal(restrictedCollectionWithTransform.find().count(), 0);\n          }));\n        },\n        function (test, expect) {\n          var self = this;\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"bar\", baz: \"baz\"}\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item1 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item2 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"adsfadf\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isTrue(e);\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"bar\"},\n            topLevelField: true\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item3 = res;\n          }));\n        },\n        function (test, expect) {\n          var self = this;\n          // This should work, because there is an update allow for things with\n          // topLevelField.\n          restrictedCollectionWithTransform.update(\n            self.item3, { $set: { xxx: true } }, expect(function (e, res) {\n              test.isFalse(e);\n              test.equal(1, res);\n            }));\n        },\n        function (test, expect) {\n          var self = this;\n          test.equal(\n            restrictedCollectionWithTransform.findOne(self.item1),\n            {_id: self.item1, foo: \"foo\", bar: \"bar\", baz: \"baz\"});\n          restrictedCollectionWithTransform.remove(\n            self.item1, expect(function (e, res) {\n              test.isFalse(e);\n            }));\n          restrictedCollectionWithTransform.remove(\n            self.item2, expect(function (e, res) {\n              test.isTrue(e);\n            }));\n        }\n      ]);\n    })();\n\n    testAsyncMulti(\"collection - insecure, \" + idGeneration, [\n      function (test, expect) {\n        insecureCollection.callClearMethod(expect(function () {\n          test.equal(insecureCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        var id = insecureCollection.insert({foo: 'bar'}, expect(function(err, res) {\n          test.equal(res, id);\n          test.equal(insecureCollection.find(id).count(), 1);\n          test.equal(insecureCollection.findOne(id).foo, 'bar');\n        }));\n        test.equal(insecureCollection.find(id).count(), 1);\n        test.equal(insecureCollection.findOne(id).foo, 'bar');\n      }\n    ]);\n\n    testAsyncMulti(\"collection - locked down, \" + idGeneration, [\n      function (test, expect) {\n        lockedDownCollection.callClearMethod(expect(function() {\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        lockedDownCollection.insert({foo: 'bar'}, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      }\n    ]);\n\n    (function () {\n      var collection = restrictedCollectionForUpdateOptionsTest;\n      var id1, id2;\n      testAsyncMulti(\"collection - update options, \" + idGeneration, [\n        // init\n        function (test, expect) {\n          collection.callClearMethod(expect(function () {\n            test.equal(collection.find().count(), 0);\n          }));\n        },\n        // put a few objects\n        function (test, expect) {\n          var doc = {canInsert: true, canUpdate: true};\n          id1 = collection.insert(doc);\n          id2 = collection.insert(doc);\n          collection.insert(doc);\n          collection.insert(doc, expect(function (err, res) {\n            test.isFalse(err);\n            test.equal(collection.find().count(), 4);\n          }));\n        },\n        // update by id\n        function (test, expect) {\n          collection.update(\n            id1,\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              test.equal(collection.find({updated: true}).count(), 1);\n            }));\n        },\n        // update by id in an object\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update with replacement operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {_id: id2, updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /In a restricted/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // upsert not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: { upserted: true }},\n            { upsert: true },\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /in a restricted/);\n              test.equal(collection.find({ upserted: true }).count(), 0);\n            }));\n        },\n        // update with rename operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$rename: {updated: 'asdf'}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /not allowed/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.update(\n              {updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/update',\n            {updated: {$exists: false}},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // make sure it doesn't think that {_id: 'foo', something: else} is ok.\n        function (test, expect) {\n          test.throws(function () {\n            collection.update(\n              {_id: id1, updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n        },\n        // remove method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.remove({updated: true});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/remove',\n            {updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        }\n      ]);\n    }) ();\n\n    _.each(\n      [restrictedCollectionDefaultInsecure, restrictedCollectionDefaultSecure],\n      function(collection) {\n        var canUpdateId, canRemoveId;\n\n        testAsyncMulti(\"collection - \" + collection.unnoncedName, [\n          // init\n          function (test, expect) {\n            collection.callClearMethod(expect(function () {\n              test.equal(collection.find().count(), 0);\n            }));\n          },\n\n          // insert with no allows passing. request is denied.\n          function (test, expect) {\n            collection.insert(\n              {},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and one deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, cantInsert: true},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and other deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, _id: Random.id()},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert one allow passes. allowed.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 1);\n              }));\n          },\n          // insert other allow passes. allowed.\n          // includes canUpdate for later.\n          function (test, expect) {\n            canUpdateId = collection.insert(\n              {canInsert2: true, canUpdate: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 2);\n              }));\n          },\n          // yet a third insert executes. this one has canRemove and\n          // cantRemove set for later.\n          function (test, expect) {\n            canRemoveId = collection.insert(\n              {canInsert: true, canRemove: true, cantRemove: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // can't update with a non-operator mutation\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {newObject: 1},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // updating dotted fields works as if we are changing their\n          // top part\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"dotted.field\": 1}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.findOne(canUpdateId).dotted.field, 1);\n              }));\n          },\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"verySecret.field\": 1}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find({verySecret: {$exists: true}}).count(), 0);\n              }));\n          },\n\n          // update doesn't do anything if no docs match\n          function (test, expect) {\n            collection.update(\n              \"doesn't exist\",\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 0);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when access is denied trying to set `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to set two fields, one of which is\n          // `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {updated: true, verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to modify docs that don't\n          // have `canUpdate` set\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update executes when it should\n          function (test, expect) {\n            collection.update(\n              canUpdateId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.find({updated: true}).count(), 1);\n              }));\n          },\n\n          // remove fails when trying to modify a doc with no `canRemove` set\n          function (test, expect) {\n            collection.remove(canUpdateId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n          // remove fails when trying to modify an doc with `cantRemove`\n          // set\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n\n          // update the doc to remove cantRemove.\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {cantRemove: false, canUpdate2: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.find({cantRemove: true}).count(), 0);\n              }));\n          },\n\n          // now remove can remove it.\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              // successfully removed\n              test.equal(collection.find().count(), 2);\n            }));\n          },\n\n          // try to remove a doc that doesn't exist. see we remove no docs.\n          function (test, expect) {\n            collection.remove('some-random-id-that-never-matches',\n                              expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 0);\n              // nothing removed\n              test.equal(collection.find().count(), 2);\n            }));\n          },\n\n          // methods can still bypass restrictions\n          function (test, expect) {\n            collection.callClearMethod(\n              expect(function (err, res) {\n                test.isFalse(err);\n                // successfully removed\n                test.equal(collection.find().count(), 0);\n            }));\n          }\n        ]);\n      });\n    testAsyncMulti(\n      \"collection - allow/deny transform must return object, \" + idGeneration,\n      [function (test, expect) {\n        restrictedCollectionForInvalidTransformTest.insert({}, expect(function (err, res) {\n          test.isTrue(err);\n        }));\n      }]);\n    testAsyncMulti(\n      \"collection - restricted collection allows client-side id, \" + idGeneration,\n      [function (test, expect) {\n        var self = this;\n        self.id = Random.id();\n        restrictedCollectionForClientIdTest.insert({_id: self.id}, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, self.id);\n          test.equal(restrictedCollectionForClientIdTest.findOne(self.id),\n                     {_id: self.id});\n        }));\n      }]);\n  });  // end idGeneration loop\n}  // end if isClient\n\n\n\n// A few simple server-only tests which don't need to coordinate collections\n// with the client..\nif (Meteor.isServer) {\n  Tinytest.add(\"collection - allow and deny validate options\", function (test) {\n    var collection = new Mongo.Collection(null);\n\n    test.throws(function () {\n      collection.allow({invalidOption: true});\n    });\n    test.throws(function () {\n      collection.deny({invalidOption: true});\n    });\n\n    _.each(['insert', 'update', 'remove', 'fetch'], function (key) {\n      var options = {};\n      options[key] = true;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = false;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = undefined;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = ['an array']; // this should be a function, not an array\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    test.throws(function () {\n      collection.allow({fetch: function () {}}); // this should be an array\n    });\n  });\n\n  Tinytest.add(\"collection - calling allow restricts\", function (test) {\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._restricted, false);\n    collection.allow({\n      insert: function() {}\n    });\n    test.equal(collection._restricted, true);\n  });\n\n  Tinytest.add(\"collection - global insecure\", function (test) {\n    // note: This test alters the global insecure status, by sneakily hacking\n    // the global Package object!\n    var insecurePackage = Package.insecure;\n\n    Package.insecure = {};\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._isInsecure(), true);\n\n    Package.insecure = undefined;\n    test.equal(collection._isInsecure(), false);\n\n    delete Package.insecure;\n    test.equal(collection._isInsecure(), false);\n\n    collection._insecure = true;\n    test.equal(collection._isInsecure(), true);\n\n    if (insecurePackage)\n      Package.insecure = insecurePackage;\n    else\n      delete Package.insecure;\n  });\n}\n"]},"hash":"a3ca6a42d6879d34b8ba66e585f050f57e56545d"}
