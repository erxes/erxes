{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mongo/observe_changes_tests.js","filenameRelative":"/packages/mongo/observe_changes_tests.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mongo/observe_changes_tests.js.map","sourceFileName":"/packages/mongo/observe_changes_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"observe_changes_tests"},"ignored":false,"code":"var makeCollection = function () {\n  if (Meteor.isServer) {\n    return new Mongo.Collection(Random.id());\n  } else {\n    return new Mongo.Collection(null);\n  }\n};\n\n_.each([{\n  added: 'added',\n  forceOrdered: true\n}, {\n  added: 'added',\n  forceOrdered: false\n}, {\n  added: 'addedBefore',\n  forceOrdered: false\n}], function (options) {\n  var added = options.added;\n  var forceOrdered = options.forceOrdered;\n  Tinytest.addAsync(\"observeChanges - single id - basics \" + added + (forceOrdered ? \" force ordered\" : \"\"), function (test, onComplete) {\n    var c = makeCollection();\n    var counter = 0;\n    var callbacks = [added, \"changed\", \"removed\"];\n    if (forceOrdered) callbacks.push(\"movedBefore\");\n    withCallbackLogger(test, callbacks, Meteor.isServer, function (logger) {\n      var barid = c.insert({\n        thing: \"stuff\"\n      });\n      var fooid = c.insert({\n        noodles: \"good\",\n        bacon: \"bad\",\n        apples: \"ok\"\n      });\n      var handle = c.find(fooid).observeChanges(logger);\n\n      if (added === 'added') {\n        logger.expectResult(added, [fooid, {\n          noodles: \"good\",\n          bacon: \"bad\",\n          apples: \"ok\"\n        }]);\n      } else {\n        logger.expectResult(added, [fooid, {\n          noodles: \"good\",\n          bacon: \"bad\",\n          apples: \"ok\"\n        }, null]);\n      }\n\n      c.update(fooid, {\n        noodles: \"alright\",\n        potatoes: \"tasty\",\n        apples: \"ok\"\n      });\n      logger.expectResult(\"changed\", [fooid, {\n        noodles: \"alright\",\n        potatoes: \"tasty\",\n        bacon: undefined\n      }]);\n      c.remove(fooid);\n      logger.expectResult(\"removed\", [fooid]);\n      c.remove(barid);\n      c.insert({\n        noodles: \"good\",\n        bacon: \"bad\",\n        apples: \"ok\"\n      });\n      logger.expectNoResult();\n      handle.stop();\n      var badCursor = c.find({}, {\n        fields: {\n          noodles: 1,\n          _id: false\n        }\n      });\n      test.throws(function () {\n        badCursor.observeChanges(logger);\n      });\n      onComplete();\n    });\n  });\n});\n\nTinytest.addAsync(\"observeChanges - callback isolation\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n    var handles = [];\n    var cursor = c.find();\n    handles.push(cursor.observeChanges(logger)); // fields-tampering observer\n\n    handles.push(cursor.observeChanges({\n      added: function (id, fields) {\n        fields.apples = 'green';\n      },\n      changed: function (id, fields) {\n        fields.apples = 'green';\n      }\n    }));\n    var fooid = c.insert({\n      apples: \"ok\"\n    });\n    logger.expectResult(\"added\", [fooid, {\n      apples: \"ok\"\n    }]);\n    c.update(fooid, {\n      apples: \"not ok\"\n    });\n    logger.expectResult(\"changed\", [fooid, {\n      apples: \"not ok\"\n    }]);\n    test.equal(c.findOne(fooid).apples, \"not ok\");\n\n    _.each(handles, function (handle) {\n      handle.stop();\n    });\n\n    onComplete();\n  });\n});\nTinytest.addAsync(\"observeChanges - single id - initial adds\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n    var fooid = c.insert({\n      noodles: \"good\",\n      bacon: \"bad\",\n      apples: \"ok\"\n    });\n    var handle = c.find(fooid).observeChanges(logger);\n    logger.expectResult(\"added\", [fooid, {\n      noodles: \"good\",\n      bacon: \"bad\",\n      apples: \"ok\"\n    }]);\n    logger.expectNoResult();\n    handle.stop();\n    onComplete();\n  });\n});\nTinytest.addAsync(\"observeChanges - unordered - initial adds\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n    var fooid = c.insert({\n      noodles: \"good\",\n      bacon: \"bad\",\n      apples: \"ok\"\n    });\n    var barid = c.insert({\n      noodles: \"good\",\n      bacon: \"weird\",\n      apples: \"ok\"\n    });\n    var handle = c.find().observeChanges(logger);\n    logger.expectResultUnordered([{\n      callback: \"added\",\n      args: [fooid, {\n        noodles: \"good\",\n        bacon: \"bad\",\n        apples: \"ok\"\n      }]\n    }, {\n      callback: \"added\",\n      args: [barid, {\n        noodles: \"good\",\n        bacon: \"weird\",\n        apples: \"ok\"\n      }]\n    }]);\n    logger.expectNoResult();\n    handle.stop();\n    onComplete();\n  });\n});\nTinytest.addAsync(\"observeChanges - unordered - basics\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n    var handle = c.find().observeChanges(logger);\n    var barid = c.insert({\n      thing: \"stuff\"\n    });\n    logger.expectResultOnly(\"added\", [barid, {\n      thing: \"stuff\"\n    }]);\n    var fooid = c.insert({\n      noodles: \"good\",\n      bacon: \"bad\",\n      apples: \"ok\"\n    });\n    logger.expectResultOnly(\"added\", [fooid, {\n      noodles: \"good\",\n      bacon: \"bad\",\n      apples: \"ok\"\n    }]);\n    c.update(fooid, {\n      noodles: \"alright\",\n      potatoes: \"tasty\",\n      apples: \"ok\"\n    });\n    c.update(fooid, {\n      noodles: \"alright\",\n      potatoes: \"tasty\",\n      apples: \"ok\"\n    });\n    logger.expectResultOnly(\"changed\", [fooid, {\n      noodles: \"alright\",\n      potatoes: \"tasty\",\n      bacon: undefined\n    }]);\n    c.remove(fooid);\n    logger.expectResultOnly(\"removed\", [fooid]);\n    c.remove(barid);\n    logger.expectResultOnly(\"removed\", [barid]);\n    fooid = c.insert({\n      noodles: \"good\",\n      bacon: \"bad\",\n      apples: \"ok\"\n    });\n    logger.expectResult(\"added\", [fooid, {\n      noodles: \"good\",\n      bacon: \"bad\",\n      apples: \"ok\"\n    }]);\n    logger.expectNoResult();\n    handle.stop();\n    onComplete();\n  });\n});\n\nif (Meteor.isServer) {\n  Tinytest.addAsync(\"observeChanges - unordered - specific fields\", function (test, onComplete) {\n    var c = makeCollection();\n    withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n      var handle = c.find({}, {\n        fields: {\n          noodles: 1,\n          bacon: 1\n        }\n      }).observeChanges(logger);\n      var barid = c.insert({\n        thing: \"stuff\"\n      });\n      logger.expectResultOnly(\"added\", [barid, {}]);\n      var fooid = c.insert({\n        noodles: \"good\",\n        bacon: \"bad\",\n        apples: \"ok\"\n      });\n      logger.expectResultOnly(\"added\", [fooid, {\n        noodles: \"good\",\n        bacon: \"bad\"\n      }]);\n      c.update(fooid, {\n        noodles: \"alright\",\n        potatoes: \"tasty\",\n        apples: \"ok\"\n      });\n      logger.expectResultOnly(\"changed\", [fooid, {\n        noodles: \"alright\",\n        bacon: undefined\n      }]);\n      c.update(fooid, {\n        noodles: \"alright\",\n        potatoes: \"meh\",\n        apples: \"ok\"\n      });\n      c.remove(fooid);\n      logger.expectResultOnly(\"removed\", [fooid]);\n      c.remove(barid);\n      logger.expectResultOnly(\"removed\", [barid]);\n      fooid = c.insert({\n        noodles: \"good\",\n        bacon: \"bad\"\n      });\n      logger.expectResult(\"added\", [fooid, {\n        noodles: \"good\",\n        bacon: \"bad\"\n      }]);\n      logger.expectNoResult();\n      handle.stop();\n      onComplete();\n    });\n  });\n  Tinytest.addAsync(\"observeChanges - unordered - specific fields + selector on excluded fields\", function (test, onComplete) {\n    var c = makeCollection();\n    withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n      var handle = c.find({\n        mac: 1,\n        cheese: 2\n      }, {\n        fields: {\n          noodles: 1,\n          bacon: 1,\n          eggs: 1\n        }\n      }).observeChanges(logger);\n      var barid = c.insert({\n        thing: \"stuff\",\n        mac: 1,\n        cheese: 2\n      });\n      logger.expectResultOnly(\"added\", [barid, {}]);\n      var fooid = c.insert({\n        noodles: \"good\",\n        bacon: \"bad\",\n        apples: \"ok\",\n        mac: 1,\n        cheese: 2\n      });\n      logger.expectResultOnly(\"added\", [fooid, {\n        noodles: \"good\",\n        bacon: \"bad\"\n      }]);\n      c.update(fooid, {\n        noodles: \"alright\",\n        potatoes: \"tasty\",\n        apples: \"ok\",\n        mac: 1,\n        cheese: 2\n      });\n      logger.expectResultOnly(\"changed\", [fooid, {\n        noodles: \"alright\",\n        bacon: undefined\n      }]); // Doesn't get update event, since modifies only hidden fields\n\n      c.update(fooid, {\n        noodles: \"alright\",\n        potatoes: \"meh\",\n        apples: \"ok\",\n        mac: 1,\n        cheese: 2\n      });\n      logger.expectNoResult();\n      c.remove(fooid);\n      logger.expectResultOnly(\"removed\", [fooid]);\n      c.remove(barid);\n      logger.expectResultOnly(\"removed\", [barid]);\n      fooid = c.insert({\n        noodles: \"good\",\n        bacon: \"bad\",\n        mac: 1,\n        cheese: 2\n      });\n      logger.expectResult(\"added\", [fooid, {\n        noodles: \"good\",\n        bacon: \"bad\"\n      }]);\n      logger.expectNoResult();\n      handle.stop();\n      onComplete();\n    });\n  });\n}\n\nTinytest.addAsync(\"observeChanges - unordered - specific fields + modify on excluded fields\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n    var handle = c.find({\n      mac: 1,\n      cheese: 2\n    }, {\n      fields: {\n        noodles: 1,\n        bacon: 1,\n        eggs: 1\n      }\n    }).observeChanges(logger);\n    var fooid = c.insert({\n      noodles: \"good\",\n      bacon: \"bad\",\n      apples: \"ok\",\n      mac: 1,\n      cheese: 2\n    });\n    logger.expectResultOnly(\"added\", [fooid, {\n      noodles: \"good\",\n      bacon: \"bad\"\n    }]); // Noodles go into shadow, mac appears as eggs\n\n    c.update(fooid, {\n      $rename: {\n        noodles: 'shadow',\n        apples: 'eggs'\n      }\n    });\n    logger.expectResultOnly(\"changed\", [fooid, {\n      eggs: \"ok\",\n      noodles: undefined\n    }]);\n    c.remove(fooid);\n    logger.expectResultOnly(\"removed\", [fooid]);\n    logger.expectNoResult();\n    handle.stop();\n    onComplete();\n  });\n});\nTinytest.addAsync(\"observeChanges - unordered - unset parent of observed field\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, ['added', 'changed', 'removed'], Meteor.isServer, function (logger) {\n    var handle = c.find({}, {\n      fields: {\n        'type.name': 1\n      }\n    }).observeChanges(logger);\n    var id = c.insert({\n      type: {\n        name: 'foobar'\n      }\n    });\n    logger.expectResultOnly('added', [id, {\n      type: {\n        name: 'foobar'\n      }\n    }]);\n    c.update(id, {\n      $unset: {\n        type: 1\n      }\n    });\n    test.equal(c.find().fetch(), [{\n      _id: id\n    }]);\n    logger.expectResultOnly('changed', [id, {\n      type: undefined\n    }]);\n    handle.stop();\n    onComplete();\n  });\n});\nTinytest.addAsync(\"observeChanges - unordered - enters and exits result set through change\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n    var handle = c.find({\n      noodles: \"good\"\n    }).observeChanges(logger);\n    var barid = c.insert({\n      thing: \"stuff\"\n    });\n    var fooid = c.insert({\n      noodles: \"good\",\n      bacon: \"bad\",\n      apples: \"ok\"\n    });\n    logger.expectResultOnly(\"added\", [fooid, {\n      noodles: \"good\",\n      bacon: \"bad\",\n      apples: \"ok\"\n    }]);\n    c.update(fooid, {\n      noodles: \"alright\",\n      potatoes: \"tasty\",\n      apples: \"ok\"\n    });\n    logger.expectResultOnly(\"removed\", [fooid]);\n    c.remove(fooid);\n    c.remove(barid);\n    fooid = c.insert({\n      noodles: \"ok\",\n      bacon: \"bad\",\n      apples: \"ok\"\n    });\n    c.update(fooid, {\n      noodles: \"good\",\n      potatoes: \"tasty\",\n      apples: \"ok\"\n    });\n    logger.expectResult(\"added\", [fooid, {\n      noodles: \"good\",\n      potatoes: \"tasty\",\n      apples: \"ok\"\n    }]);\n    logger.expectNoResult();\n    handle.stop();\n    onComplete();\n  });\n});\n\nif (Meteor.isServer) {\n  testAsyncMulti(\"observeChanges - tailable\", [function (test, expect) {\n    var self = this;\n    var collName = \"cap_\" + Random.id();\n    var coll = new Mongo.Collection(collName);\n\n    coll._createCappedCollection(1000000);\n\n    self.xs = [];\n    self.expects = [];\n\n    self.insert = function (fields) {\n      coll.insert(_.extend({\n        ts: new MongoInternals.MongoTimestamp(0, 0)\n      }, fields));\n    }; // Tailable observe shouldn't show things that are in the initial\n    // contents.\n\n\n    self.insert({\n      x: 1\n    }); // Wait for one added call before going to the next test function.\n\n    self.expects.push(expect());\n    var cursor = coll.find({\n      y: {\n        $ne: 7\n      }\n    }, {\n      tailable: true\n    });\n    self.handle = cursor.observeChanges({\n      added: function (id, fields) {\n        self.xs.push(fields.x);\n        test.notEqual(self.expects.length, 0);\n        self.expects.pop()();\n      },\n      changed: function () {\n        test.fail({\n          unexpected: \"changed\"\n        });\n      },\n      removed: function () {\n        test.fail({\n          unexpected: \"removed\"\n        });\n      }\n    }); // Nothing happens synchronously.\n\n    test.equal(self.xs, []);\n  }, function (test, expect) {\n    var self = this; // The cursors sees the first element.\n\n    test.equal(self.xs, [1]);\n    self.xs = [];\n    self.insert({\n      x: 2,\n      y: 3\n    });\n    self.insert({\n      x: 3,\n      y: 7\n    }); // filtered out by the query\n\n    self.insert({\n      x: 4\n    }); // Expect two added calls to happen.\n\n    self.expects = [expect(), expect()];\n  }, function (test, expect) {\n    var self = this;\n    test.equal(self.xs, [2, 4]);\n    self.xs = [];\n    self.handle.stop();\n    self.insert({\n      x: 5\n    }); // XXX This timeout isn't perfect but it's pretty hard to prove that an\n    // event WON'T happen without something like a write fence.\n\n    Meteor.setTimeout(expect(), 1000);\n  }, function (test, expect) {\n    var self = this;\n    test.equal(self.xs, []);\n  }]);\n}\n\ntestAsyncMulti(\"observeChanges - bad query\", [function (test, expect) {\n  var c = makeCollection();\n\n  var observeThrows = function () {\n    test.throws(function () {\n      c.find({\n        __id: {\n          $in: null\n        }\n      }).observeChanges({\n        added: function () {\n          test.fail(\"added shouldn't be called\");\n        }\n      });\n    }, '$in needs an array');\n  };\n\n  if (Meteor.isClient) {\n    observeThrows();\n    return;\n  } // Test that if two copies of the same bad observeChanges run in parallel\n  // and are de-duped, both observeChanges calls will throw.\n\n\n  var Fiber = Npm.require('fibers');\n\n  var Future = Npm.require('fibers/future');\n\n  var f1 = new Future();\n  var f2 = new Future();\n  Fiber(function () {\n    // The observeChanges call in here will yield when we talk to mongod,\n    // which will allow the second Fiber to start and observe a duplicate\n    // query.\n    observeThrows();\n    f1['return']();\n  }).run();\n  Fiber(function () {\n    test.isFalse(f1.isResolved()); // first observe hasn't thrown yet\n\n    observeThrows();\n    f2['return']();\n  }).run();\n  f1.wait();\n  f2.wait();\n}]);","map":{"version":3,"sources":["/packages/mongo/observe_changes_tests.js"],"names":["makeCollection","Meteor","isServer","Mongo","Collection","Random","id","_","each","added","forceOrdered","options","Tinytest","addAsync","test","onComplete","c","counter","callbacks","push","withCallbackLogger","logger","barid","insert","thing","fooid","noodles","bacon","apples","handle","find","observeChanges","expectResult","update","potatoes","undefined","remove","expectNoResult","stop","badCursor","fields","_id","throws","handles","cursor","changed","equal","findOne","expectResultUnordered","callback","args","expectResultOnly","mac","cheese","eggs","$rename","type","name","$unset","fetch","testAsyncMulti","expect","self","collName","coll","_createCappedCollection","xs","expects","extend","ts","MongoInternals","MongoTimestamp","x","y","$ne","tailable","notEqual","length","pop","fail","unexpected","removed","setTimeout","observeThrows","__id","$in","isClient","Fiber","Npm","require","Future","f1","f2","run","isFalse","isResolved","wait"],"mappings":"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","file":"/packages/mongo/observe_changes_tests.js.map","sourcesContent":["var makeCollection = function () {\n  if (Meteor.isServer) {\n    return new Mongo.Collection(Random.id());\n  } else {\n    return new Mongo.Collection(null);\n  }\n};\n\n_.each ([{added: 'added', forceOrdered: true},\n         {added: 'added', forceOrdered: false},\n         {added: 'addedBefore', forceOrdered: false}], function (options) {\n  var added = options.added;\n  var forceOrdered = options.forceOrdered;\n\n  Tinytest.addAsync(\"observeChanges - single id - basics \" + added\n                    + (forceOrdered ? \" force ordered\" : \"\"),\n                    function (test, onComplete) {\n    var c = makeCollection();\n    var counter = 0;\n    var callbacks = [added, \"changed\", \"removed\"];\n    if (forceOrdered)\n      callbacks.push(\"movedBefore\");\n    withCallbackLogger(test,\n                       callbacks,\n                       Meteor.isServer,\n                       function (logger) {\n    var barid = c.insert({thing: \"stuff\"});\n    var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n\n    var handle = c.find(fooid).observeChanges(logger);\n    if (added === 'added') {\n      logger.expectResult(added, [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}]);\n    } else {\n      logger.expectResult(added,\n                          [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}, null]);\n    }\n    c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\"});\n    logger.expectResult(\"changed\",\n                        [fooid, {noodles: \"alright\", potatoes: \"tasty\", bacon: undefined}]);\n\n    c.remove(fooid);\n    logger.expectResult(\"removed\", [fooid]);\n\n    c.remove(barid);\n\n    c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n    logger.expectNoResult();\n    handle.stop();\n\n    var badCursor = c.find({}, {fields: {noodles: 1, _id: false}});\n    test.throws(function () {\n      badCursor.observeChanges(logger);\n    });\n\n    onComplete();\n    });\n  });\n});\n\nTinytest.addAsync(\"observeChanges - callback isolation\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n    var handles = [];\n    var cursor = c.find();\n    handles.push(cursor.observeChanges(logger));\n    // fields-tampering observer\n    handles.push(cursor.observeChanges({\n      added: function(id, fields) {\n        fields.apples = 'green';\n      },\n      changed: function(id, fields) {\n        fields.apples = 'green';\n      },\n    }));\n\n    var fooid = c.insert({apples: \"ok\"});\n    logger.expectResult(\"added\", [fooid, {apples: \"ok\"}]);\n\n    c.update(fooid, {apples: \"not ok\"});\n    logger.expectResult(\"changed\", [fooid, {apples: \"not ok\"}]);\n\n    test.equal(c.findOne(fooid).apples, \"not ok\");\n\n    _.each(handles, function(handle) { handle.stop(); });\n    onComplete();\n  });\n\n});\n\nTinytest.addAsync(\"observeChanges - single id - initial adds\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n  var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n  var handle = c.find(fooid).observeChanges(logger);\n  logger.expectResult(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}]);\n  logger.expectNoResult();\n  handle.stop();\n  onComplete();\n  });\n});\n\n\n\nTinytest.addAsync(\"observeChanges - unordered - initial adds\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n  var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n  var barid = c.insert({noodles: \"good\", bacon: \"weird\", apples: \"ok\"});\n  var handle = c.find().observeChanges(logger);\n  logger.expectResultUnordered([\n    {callback: \"added\",\n     args: [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}]},\n    {callback: \"added\",\n     args: [barid, {noodles: \"good\", bacon: \"weird\", apples: \"ok\"}]}\n  ]);\n  logger.expectNoResult();\n  handle.stop();\n  onComplete();\n  });\n});\n\nTinytest.addAsync(\"observeChanges - unordered - basics\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n  var handle = c.find().observeChanges(logger);\n  var barid = c.insert({thing: \"stuff\"});\n  logger.expectResultOnly(\"added\", [barid, {thing: \"stuff\"}]);\n\n  var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n\n  logger.expectResultOnly(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}]);\n\n  c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\"});\n  c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\"});\n  logger.expectResultOnly(\"changed\",\n                      [fooid, {noodles: \"alright\", potatoes: \"tasty\", bacon: undefined}]);\n  c.remove(fooid);\n  logger.expectResultOnly(\"removed\", [fooid]);\n  c.remove(barid);\n  logger.expectResultOnly(\"removed\", [barid]);\n\n  fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n\n  logger.expectResult(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}]);\n  logger.expectNoResult();\n  handle.stop();\n  onComplete();\n  });\n});\n\nif (Meteor.isServer) {\n  Tinytest.addAsync(\"observeChanges - unordered - specific fields\", function (test, onComplete) {\n    var c = makeCollection();\n    withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n      var handle = c.find({}, {fields:{noodles: 1, bacon: 1}}).observeChanges(logger);\n      var barid = c.insert({thing: \"stuff\"});\n      logger.expectResultOnly(\"added\", [barid, {}]);\n\n      var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n\n      logger.expectResultOnly(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\"}]);\n\n      c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\"});\n      logger.expectResultOnly(\"changed\",\n                              [fooid, {noodles: \"alright\", bacon: undefined}]);\n      c.update(fooid, {noodles: \"alright\", potatoes: \"meh\", apples: \"ok\"});\n      c.remove(fooid);\n      logger.expectResultOnly(\"removed\", [fooid]);\n      c.remove(barid);\n      logger.expectResultOnly(\"removed\", [barid]);\n\n      fooid = c.insert({noodles: \"good\", bacon: \"bad\"});\n\n      logger.expectResult(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\"}]);\n      logger.expectNoResult();\n      handle.stop();\n      onComplete();\n    });\n  });\n\n  Tinytest.addAsync(\"observeChanges - unordered - specific fields + selector on excluded fields\", function (test, onComplete) {\n    var c = makeCollection();\n    withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n      var handle = c.find({ mac: 1, cheese: 2 },\n                          {fields:{noodles: 1, bacon: 1, eggs: 1}}).observeChanges(logger);\n      var barid = c.insert({thing: \"stuff\", mac: 1, cheese: 2});\n      logger.expectResultOnly(\"added\", [barid, {}]);\n\n      var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\", mac: 1, cheese: 2});\n\n      logger.expectResultOnly(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\"}]);\n\n      c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\", mac: 1, cheese: 2});\n      logger.expectResultOnly(\"changed\",\n                              [fooid, {noodles: \"alright\", bacon: undefined}]);\n\n      // Doesn't get update event, since modifies only hidden fields\n      c.update(fooid, {noodles: \"alright\", potatoes: \"meh\", apples: \"ok\", mac: 1, cheese: 2});\n      logger.expectNoResult();\n\n      c.remove(fooid);\n      logger.expectResultOnly(\"removed\", [fooid]);\n      c.remove(barid);\n      logger.expectResultOnly(\"removed\", [barid]);\n\n      fooid = c.insert({noodles: \"good\", bacon: \"bad\", mac: 1, cheese: 2});\n\n      logger.expectResult(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\"}]);\n      logger.expectNoResult();\n      handle.stop();\n      onComplete();\n    });\n  });\n}\n\nTinytest.addAsync(\"observeChanges - unordered - specific fields + modify on excluded fields\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n    var handle = c.find({ mac: 1, cheese: 2 },\n                        {fields:{noodles: 1, bacon: 1, eggs: 1}}).observeChanges(logger);\n    var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\", mac: 1, cheese: 2});\n\n    logger.expectResultOnly(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\"}]);\n\n\n    // Noodles go into shadow, mac appears as eggs\n    c.update(fooid, {$rename: { noodles: 'shadow', apples: 'eggs' }});\n    logger.expectResultOnly(\"changed\",\n                            [fooid, {eggs:\"ok\", noodles: undefined}]);\n\n    c.remove(fooid);\n    logger.expectResultOnly(\"removed\", [fooid]);\n    logger.expectNoResult();\n    handle.stop();\n    onComplete();\n  });\n});\n\nTinytest.addAsync(\n  \"observeChanges - unordered - unset parent of observed field\",\n  function (test, onComplete) {\n    var c = makeCollection();\n    withCallbackLogger(\n      test, ['added', 'changed', 'removed'], Meteor.isServer,\n      function (logger) {\n        var handle = c.find({}, {fields: {'type.name': 1}}).observeChanges(logger);\n        var id = c.insert({ type: { name: 'foobar' } });\n        logger.expectResultOnly('added', [id, { type: { name: 'foobar' } }]);\n\n        c.update(id, { $unset: { type: 1 } });\n        test.equal(c.find().fetch(), [{ _id: id }]);\n        logger.expectResultOnly('changed', [id, { type: undefined }]);\n\n        handle.stop();\n        onComplete();\n      }\n    );\n  }\n);\n\n\n\nTinytest.addAsync(\"observeChanges - unordered - enters and exits result set through change\", function (test, onComplete) {\n  var c = makeCollection();\n  withCallbackLogger(test, [\"added\", \"changed\", \"removed\"], Meteor.isServer, function (logger) {\n  var handle = c.find({noodles: \"good\"}).observeChanges(logger);\n  var barid = c.insert({thing: \"stuff\"});\n\n  var fooid = c.insert({noodles: \"good\", bacon: \"bad\", apples: \"ok\"});\n  logger.expectResultOnly(\"added\", [fooid, {noodles: \"good\", bacon: \"bad\", apples: \"ok\"}]);\n\n  c.update(fooid, {noodles: \"alright\", potatoes: \"tasty\", apples: \"ok\"});\n  logger.expectResultOnly(\"removed\",\n                      [fooid]);\n  c.remove(fooid);\n  c.remove(barid);\n\n  fooid = c.insert({noodles: \"ok\", bacon: \"bad\", apples: \"ok\"});\n  c.update(fooid, {noodles: \"good\", potatoes: \"tasty\", apples: \"ok\"});\n  logger.expectResult(\"added\", [fooid, {noodles: \"good\", potatoes: \"tasty\", apples: \"ok\"}]);\n  logger.expectNoResult();\n  handle.stop();\n  onComplete();\n  });\n});\n\n\nif (Meteor.isServer) {\n  testAsyncMulti(\"observeChanges - tailable\", [\n    function (test, expect) {\n      var self = this;\n      var collName = \"cap_\" + Random.id();\n      var coll = new Mongo.Collection(collName);\n      coll._createCappedCollection(1000000);\n      self.xs = [];\n      self.expects = [];\n      self.insert = function (fields) {\n        coll.insert(_.extend({ts: new MongoInternals.MongoTimestamp(0, 0)},\n                             fields));\n      };\n\n      // Tailable observe shouldn't show things that are in the initial\n      // contents.\n      self.insert({x: 1});\n      // Wait for one added call before going to the next test function.\n      self.expects.push(expect());\n\n      var cursor = coll.find({y: {$ne: 7}}, {tailable: true});\n      self.handle = cursor.observeChanges({\n        added: function (id, fields) {\n          self.xs.push(fields.x);\n          test.notEqual(self.expects.length, 0);\n          self.expects.pop()();\n        },\n        changed: function () {\n          test.fail({unexpected: \"changed\"});\n        },\n        removed: function () {\n          test.fail({unexpected: \"removed\"});\n        }\n      });\n\n      // Nothing happens synchronously.\n      test.equal(self.xs, []);\n    },\n    function (test, expect) {\n      var self = this;\n      // The cursors sees the first element.\n      test.equal(self.xs, [1]);\n      self.xs = [];\n\n      self.insert({x: 2, y: 3});\n      self.insert({x: 3, y: 7});  // filtered out by the query\n      self.insert({x: 4});\n      // Expect two added calls to happen.\n      self.expects = [expect(), expect()];\n    },\n    function (test, expect) {\n      var self = this;\n      test.equal(self.xs, [2, 4]);\n      self.xs = [];\n      self.handle.stop();\n\n      self.insert({x: 5});\n      // XXX This timeout isn't perfect but it's pretty hard to prove that an\n      // event WON'T happen without something like a write fence.\n      Meteor.setTimeout(expect(), 1000);\n    },\n    function (test, expect) {\n      var self = this;\n      test.equal(self.xs, []);\n    }\n  ]);\n}\n\n\ntestAsyncMulti(\"observeChanges - bad query\", [\n  function (test, expect) {\n    var c = makeCollection();\n    var observeThrows = function () {\n      test.throws(function () {\n        c.find({__id: {$in: null}}).observeChanges({\n          added: function () {\n            test.fail(\"added shouldn't be called\");\n          }\n        });\n      }, '$in needs an array');\n    };\n\n    if (Meteor.isClient) {\n      observeThrows();\n      return;\n    }\n\n    // Test that if two copies of the same bad observeChanges run in parallel\n    // and are de-duped, both observeChanges calls will throw.\n    var Fiber = Npm.require('fibers');\n    var Future = Npm.require('fibers/future');\n    var f1 = new Future;\n    var f2 = new Future;\n    Fiber(function () {\n      // The observeChanges call in here will yield when we talk to mongod,\n      // which will allow the second Fiber to start and observe a duplicate\n      // query.\n      observeThrows();\n      f1['return']();\n    }).run();\n    Fiber(function () {\n      test.isFalse(f1.isResolved());  // first observe hasn't thrown yet\n      observeThrows();\n      f2['return']();\n    }).run();\n    f1.wait();\n    f2.wait();\n  }\n]);\n"]},"hash":"d02aa7021425846b059617b2ba7bc2ec042bee4b"}
