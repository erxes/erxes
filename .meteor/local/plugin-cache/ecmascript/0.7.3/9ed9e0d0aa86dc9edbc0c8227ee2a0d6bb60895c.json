{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-client/livedata_test_service.js","filenameRelative":"/packages/ddp-client/livedata_test_service.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-client/livedata_test_service.js.map","sourceFileName":"/packages/ddp-client/livedata_test_service.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"livedata_test_service"},"ignored":false,"code":"Meteor.methods({\n  nothing: function () {// No need to check if there are no arguments.\n  },\n  echo: function () /* arguments */{\n    check(arguments, [Match.Any]);\n    return _.toArray(arguments);\n  },\n  echoOne: function () /*arguments*/{\n    check(arguments, [Match.Any]);\n    return arguments[0];\n  },\n  exception: function (where, options) {\n    check(where, String);\n    check(options, Match.Optional({\n      intended: Match.Optional(Boolean),\n      throwThroughFuture: Match.Optional(Boolean)\n    }));\n    options = options || {};\n    var shouldThrow = Meteor.isServer && where === \"server\" || Meteor.isClient && where === \"client\" || where === \"both\";\n\n    if (shouldThrow) {\n      var e;\n      if (options.intended) e = new Meteor.Error(999, \"Client-visible test exception\");else e = new Error(\"Test method throwing an exception\");\n      e.expected = true; // We used to improperly serialize errors that were thrown through a\n      // future first.\n\n      if (Meteor.isServer && options.throwThroughFuture) {\n        var Future = Npm.require('fibers/future');\n\n        var f = new Future();\n        f['throw'](e);\n        e = f.wait();\n      }\n\n      throw e;\n    }\n  },\n  setUserId: function (userId) {\n    check(userId, Match.OneOf(String, null));\n    this.setUserId(userId);\n  }\n}); // Methods to help test applying methods with `wait: true`: delayedTrue returns\n// true 1s after being run unless makeDelayedTrueImmediatelyReturnFalse was run\n// in the meanwhile. Increasing the timeout makes the \"wait: true\" test slower;\n// decreasing the timeout makes the \"wait: false\" test flakier (ie, the timeout\n// could fire before processing the second method).\n\nif (Meteor.isServer) {\n  // Keys are random tokens, used to isolate multiple test invocations from each\n  // other.\n  var waiters = {};\n\n  var path = Npm.require('path');\n\n  var Future = Npm.require(path.join('fibers', 'future'));\n\n  var returnThroughFuture = function (token, returnValue) {\n    // Make sure that when we call return, the fields are already cleared.\n    var record = waiters[token];\n    if (!record) return;\n    delete waiters[token];\n    record.future['return'](returnValue);\n  };\n\n  Meteor.methods({\n    delayedTrue: function (token) {\n      check(token, String);\n      var record = waiters[token] = {\n        future: new Future(),\n        timer: Meteor.setTimeout(function () {\n          returnThroughFuture(token, true);\n        }, 1000)\n      };\n      this.unblock();\n      return record.future.wait();\n    },\n    makeDelayedTrueImmediatelyReturnFalse: function (token) {\n      check(token, String);\n      var record = waiters[token];\n      if (!record) return; // since delayedTrue's timeout had already run\n\n      clearTimeout(record.timer);\n      returnThroughFuture(token, false);\n    }\n  });\n} /*****/\n\nLedger = new Mongo.Collection(\"ledger\");\nLedger.allow({\n  insert: function () {\n    return true;\n  },\n  update: function () {\n    return true;\n  },\n  remove: function () {\n    return true;\n  },\n  fetch: []\n});\nMeteor.startup(function () {\n  if (Meteor.isServer) Ledger.remove({}); // XXX can this please be Ledger.remove()?\n});\nif (Meteor.isServer) Meteor.publish('ledger', function (world) {\n  check(world, String);\n  return Ledger.find({\n    world: world\n  });\n});\nMeteor.methods({\n  'ledger/transfer': function (world, from_name, to_name, amount, cheat) {\n    check(world, String);\n    check(from_name, String);\n    check(to_name, String);\n    check(amount, Number);\n    check(cheat, Match.Optional(Boolean));\n    var from = Ledger.findOne({\n      name: from_name,\n      world: world\n    });\n    var to = Ledger.findOne({\n      name: to_name,\n      world: world\n    });\n    if (Meteor.isServer) cheat = false;\n    if (!from) throw new Meteor.Error(404, \"No such account \" + from_name + \" in \" + world);\n    if (!to) throw new Meteor.Error(404, \"No such account \" + to_name + \" in \" + world);\n    if (from.balance < amount && !cheat) throw new Meteor.Error(409, \"Insufficient funds\");\n    Ledger.update(from._id, {\n      $inc: {\n        balance: -amount\n      }\n    });\n    Ledger.update(to._id, {\n      $inc: {\n        balance: amount\n      }\n    });\n  }\n}); /*****/ /// Helpers for \"livedata - changing userid reruns subscriptions...\"\n\nobjectsWithUsers = new Mongo.Collection(\"objectsWithUsers\");\n\nif (Meteor.isServer) {\n  objectsWithUsers.remove({});\n  objectsWithUsers.insert({\n    name: \"owned by none\",\n    ownerUserIds: [null]\n  });\n  objectsWithUsers.insert({\n    name: \"owned by one - a\",\n    ownerUserIds: [\"1\"]\n  });\n  objectsWithUsers.insert({\n    name: \"owned by one/two - a\",\n    ownerUserIds: [\"1\", \"2\"]\n  });\n  objectsWithUsers.insert({\n    name: \"owned by one/two - b\",\n    ownerUserIds: [\"1\", \"2\"]\n  });\n  objectsWithUsers.insert({\n    name: \"owned by two - a\",\n    ownerUserIds: [\"2\"]\n  });\n  objectsWithUsers.insert({\n    name: \"owned by two - b\",\n    ownerUserIds: [\"2\"]\n  });\n  Meteor.publish(\"objectsWithUsers\", function () {\n    return objectsWithUsers.find({\n      ownerUserIds: this.userId\n    }, {\n      fields: {\n        ownerUserIds: 0\n      }\n    });\n  });\n\n  (function () {\n    var userIdWhenStopped = {};\n    Meteor.publish(\"recordUserIdOnStop\", function (key) {\n      check(key, String);\n      var self = this;\n      self.onStop(function () {\n        userIdWhenStopped[key] = self.userId;\n      });\n    });\n    Meteor.methods({\n      userIdWhenStopped: function (key) {\n        check(key, String);\n        return userIdWhenStopped[key];\n      }\n    });\n  })();\n} /*****/ /// Helper for \"livedata - setUserId fails when called on server\"\n\n\nif (Meteor.isServer) {\n  Meteor.startup(function () {\n    errorThrownWhenCallingSetUserIdDirectlyOnServer = null;\n\n    try {\n      Meteor.call(\"setUserId\", \"1000\");\n    } catch (e) {\n      errorThrownWhenCallingSetUserIdDirectlyOnServer = e;\n    }\n  });\n} /// Helper for \"livedata - no setUserId after unblock\"\n\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    setUserIdAfterUnblock: function () {\n      this.unblock();\n      var threw = false;\n      var originalUserId = this.userId;\n\n      try {\n        // Calling setUserId after unblock should throw an error (and not mutate\n        // userId).\n        this.setUserId(originalUserId + \"bla\");\n      } catch (e) {\n        threw = true;\n      }\n\n      return threw && this.userId === originalUserId;\n    }\n  });\n} /*****/ /// Helper for \"livedata - overlapping universal subs\"\n\n\nif (Meteor.isServer) {\n  (function () {\n    var collName = \"overlappingUniversalSubs\";\n    var universalSubscribers = [[], []];\n\n    _.each([0, 1], function (index) {\n      Meteor.publish(null, function () {\n        var sub = this;\n        universalSubscribers[index].push(sub);\n        sub.onStop(function () {\n          universalSubscribers[index] = _.without(universalSubscribers[index], sub);\n        });\n      });\n    });\n\n    Meteor.methods({\n      testOverlappingSubs: function (token) {\n        check(token, String);\n\n        _.each(universalSubscribers[0], function (sub) {\n          sub.added(collName, token, {});\n        });\n\n        _.each(universalSubscribers[1], function (sub) {\n          sub.added(collName, token, {});\n        });\n\n        _.each(universalSubscribers[0], function (sub) {\n          sub.removed(collName, token);\n        });\n      }\n    });\n  })();\n} /// Helper for \"livedata - runtime universal sub creation\"\n\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    runtimeUniversalSubCreation: function (token) {\n      check(token, String);\n      Meteor.publish(null, function () {\n        this.added(\"runtimeSubCreation\", token, {});\n      });\n    }\n  });\n} /// Helper for \"livedata - publisher errors\"\n\n\nif (Meteor.isServer) {\n  Meteor.publish(\"publisherErrors\", function (collName, options) {\n    check(collName, String); // See below to see what options are accepted.\n\n    check(options, Object);\n    var sub = this; // First add a random item, which should be cleaned up. We use ready/onReady\n    // to make sure that the second test block is only called after the added is\n    // processed, so that there's any chance of the coll.find().count() failing.\n\n    sub.added(collName, Random.id(), {\n      foo: 42\n    });\n    sub.ready();\n\n    if (options.stopInHandler) {\n      sub.stop();\n      return;\n    }\n\n    var error;\n\n    if (options.internalError) {\n      error = new Error(\"Egads!\");\n      error.expected = true; // don't log\n    } else {\n      error = new Meteor.Error(412, \"Explicit error\");\n    }\n\n    if (options.throwInHandler) {\n      throw error;\n    } else if (options.errorInHandler) {\n      sub.error(error);\n    } else if (options.throwWhenUserIdSet) {\n      if (sub.userId) throw error;\n    } else if (options.errorLater) {\n      Meteor.defer(function () {\n        sub.error(error);\n      });\n    }\n  });\n} /*****/ /// Helpers for \"livedata - publish multiple cursors\"\n\n\nOne = new Mongo.Collection(\"collectionOne\");\nTwo = new Mongo.Collection(\"collectionTwo\");\n\nif (Meteor.isServer) {\n  One.remove({});\n  One.insert({\n    name: \"value1\"\n  });\n  One.insert({\n    name: \"value2\"\n  });\n  Two.remove({});\n  Two.insert({\n    name: \"value3\"\n  });\n  Two.insert({\n    name: \"value4\"\n  });\n  Two.insert({\n    name: \"value5\"\n  });\n  Meteor.publish(\"multiPublish\", function (options) {\n    // See below to see what options are accepted.\n    check(options, Object);\n\n    if (options.normal) {\n      return [One.find(), Two.find()];\n    } else if (options.dup) {\n      // Suppress the log of the expected internal error.\n      Meteor._suppress_log(1);\n\n      return [One.find(), One.find({\n        name: \"value2\"\n      }), // multiple cursors for one collection - error\n      Two.find()];\n    } else if (options.notCursor) {\n      // Suppress the log of the expected internal error.\n      Meteor._suppress_log(1);\n\n      return [One.find(), \"not a cursor\", Two.find()];\n    } else throw \"unexpected options\";\n  });\n} /// Helper for \"livedata - result by value\"\n\n\nvar resultByValueArrays = {};\nMeteor.methods({\n  'getArray': function (testId) {\n    if (!_.has(resultByValueArrays, testId)) resultByValueArrays[testId] = [];\n    return resultByValueArrays[testId];\n  },\n  'pushToArray': function (testId, value) {\n    if (!_.has(resultByValueArrays, testId)) resultByValueArrays[testId] = [];\n    resultByValueArrays[testId].push(value);\n  }\n});","map":{"version":3,"sources":["/packages/ddp-client/livedata_test_service.js"],"names":["Meteor","methods","nothing","echo","check","arguments","Match","Any","_","toArray","echoOne","exception","where","options","String","Optional","intended","Boolean","throwThroughFuture","shouldThrow","isServer","isClient","e","Error","expected","Future","Npm","require","f","wait","setUserId","userId","OneOf","waiters","path","join","returnThroughFuture","token","returnValue","record","future","delayedTrue","timer","setTimeout","unblock","makeDelayedTrueImmediatelyReturnFalse","clearTimeout","Ledger","Mongo","Collection","allow","insert","update","remove","fetch","startup","publish","world","find","from_name","to_name","amount","cheat","Number","from","findOne","name","to","balance","_id","$inc","objectsWithUsers","ownerUserIds","fields","userIdWhenStopped","key","self","onStop","errorThrownWhenCallingSetUserIdDirectlyOnServer","call","setUserIdAfterUnblock","threw","originalUserId","collName","universalSubscribers","each","index","sub","push","without","testOverlappingSubs","added","removed","runtimeUniversalSubCreation","Object","Random","id","foo","ready","stopInHandler","stop","error","internalError","throwInHandler","errorInHandler","throwWhenUserIdSet","errorLater","defer","One","Two","normal","dup","_suppress_log","notCursor","resultByValueArrays","testId","has","value"],"mappings":"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","file":"/packages/ddp-client/livedata_test_service.js.map","sourcesContent":["Meteor.methods({\n  nothing: function () {\n    // No need to check if there are no arguments.\n  },\n  echo: function (/* arguments */) {\n    check(arguments, [Match.Any]);\n    return _.toArray(arguments);\n  },\n  echoOne: function (/*arguments*/) {\n    check(arguments, [Match.Any]);\n    return arguments[0];\n  },\n  exception: function (where, options) {\n    check(where, String);\n    check(options, Match.Optional({\n      intended: Match.Optional(Boolean),\n      throwThroughFuture: Match.Optional(Boolean)\n    }));\n    options = options || {};\n    var shouldThrow =\n      (Meteor.isServer && where === \"server\") ||\n      (Meteor.isClient && where === \"client\") ||\n      where === \"both\";\n\n    if (shouldThrow) {\n      var e;\n      if (options.intended)\n        e = new Meteor.Error(999, \"Client-visible test exception\");\n      else\n        e = new Error(\"Test method throwing an exception\");\n      e.expected = true;\n\n      // We used to improperly serialize errors that were thrown through a\n      // future first.\n      if (Meteor.isServer && options.throwThroughFuture) {\n        var Future = Npm.require('fibers/future');\n        var f = new Future;\n        f['throw'](e);\n        e = f.wait();\n      }\n      throw e;\n    }\n  },\n  setUserId: function(userId) {\n    check(userId, Match.OneOf(String, null));\n    this.setUserId(userId);\n  }\n});\n\n// Methods to help test applying methods with `wait: true`: delayedTrue returns\n// true 1s after being run unless makeDelayedTrueImmediatelyReturnFalse was run\n// in the meanwhile. Increasing the timeout makes the \"wait: true\" test slower;\n// decreasing the timeout makes the \"wait: false\" test flakier (ie, the timeout\n// could fire before processing the second method).\nif (Meteor.isServer) {\n  // Keys are random tokens, used to isolate multiple test invocations from each\n  // other.\n  var waiters = {};\n\n  var path = Npm.require('path');\n  var Future = Npm.require(path.join('fibers', 'future'));\n\n  var returnThroughFuture = function (token, returnValue) {\n    // Make sure that when we call return, the fields are already cleared.\n    var record = waiters[token];\n    if (!record)\n      return;\n    delete waiters[token];\n    record.future['return'](returnValue);\n  };\n\n  Meteor.methods({\n    delayedTrue: function(token) {\n      check(token, String);\n      var record = waiters[token] = {\n        future: new Future(),\n        timer: Meteor.setTimeout(function() {\n          returnThroughFuture(token, true);\n        }, 1000)\n      };\n\n      this.unblock();\n      return record.future.wait();\n    },\n    makeDelayedTrueImmediatelyReturnFalse: function(token) {\n      check(token, String);\n      var record = waiters[token];\n      if (!record)\n        return; // since delayedTrue's timeout had already run\n      clearTimeout(record.timer);\n      returnThroughFuture(token, false);\n    }\n  });\n}\n\n/*****/\n\nLedger = new Mongo.Collection(\"ledger\");\nLedger.allow({\n  insert: function() { return true; },\n  update: function() { return true; },\n  remove: function() { return true; },\n  fetch: []\n});\n\nMeteor.startup(function () {\n  if (Meteor.isServer)\n    Ledger.remove({}); // XXX can this please be Ledger.remove()?\n});\n\nif (Meteor.isServer)\n  Meteor.publish('ledger', function (world) {\n    check(world, String);\n    return Ledger.find({world: world});\n  });\n\nMeteor.methods({\n  'ledger/transfer': function (world, from_name, to_name, amount, cheat) {\n    check(world, String);\n    check(from_name, String);\n    check(to_name, String);\n    check(amount, Number);\n    check(cheat, Match.Optional(Boolean));\n    var from = Ledger.findOne({name: from_name, world: world});\n    var to = Ledger.findOne({name: to_name, world: world});\n\n    if (Meteor.isServer)\n      cheat = false;\n\n    if (!from)\n      throw new Meteor.Error(404,\n                             \"No such account \" + from_name + \" in \" + world);\n\n    if (!to)\n      throw new Meteor.Error(404,\n                             \"No such account \" + to_name + \" in \" + world);\n\n    if (from.balance < amount && !cheat)\n      throw new Meteor.Error(409, \"Insufficient funds\");\n\n    Ledger.update(from._id, {$inc: {balance: -amount}});\n    Ledger.update(to._id, {$inc: {balance: amount}});\n  }\n});\n\n/*****/\n\n/// Helpers for \"livedata - changing userid reruns subscriptions...\"\n\nobjectsWithUsers = new Mongo.Collection(\"objectsWithUsers\");\n\nif (Meteor.isServer) {\n  objectsWithUsers.remove({});\n  objectsWithUsers.insert({name: \"owned by none\", ownerUserIds: [null]});\n  objectsWithUsers.insert({name: \"owned by one - a\", ownerUserIds: [\"1\"]});\n  objectsWithUsers.insert({name: \"owned by one/two - a\", ownerUserIds: [\"1\", \"2\"]});\n  objectsWithUsers.insert({name: \"owned by one/two - b\", ownerUserIds: [\"1\", \"2\"]});\n  objectsWithUsers.insert({name: \"owned by two - a\", ownerUserIds: [\"2\"]});\n  objectsWithUsers.insert({name: \"owned by two - b\", ownerUserIds: [\"2\"]});\n\n  Meteor.publish(\"objectsWithUsers\", function() {\n    return objectsWithUsers.find({ownerUserIds: this.userId},\n                                 {fields: {ownerUserIds: 0}});\n  });\n\n  (function () {\n    var userIdWhenStopped = {};\n    Meteor.publish(\"recordUserIdOnStop\", function (key) {\n      check(key, String);\n      var self = this;\n      self.onStop(function() {\n        userIdWhenStopped[key] = self.userId;\n      });\n    });\n\n    Meteor.methods({\n      userIdWhenStopped: function (key) {\n        check(key, String);\n        return userIdWhenStopped[key];\n      }\n    });\n  })();\n}\n\n/*****/\n\n/// Helper for \"livedata - setUserId fails when called on server\"\n\nif (Meteor.isServer) {\n  Meteor.startup(function() {\n    errorThrownWhenCallingSetUserIdDirectlyOnServer = null;\n    try {\n      Meteor.call(\"setUserId\", \"1000\");\n    } catch (e) {\n      errorThrownWhenCallingSetUserIdDirectlyOnServer = e;\n    }\n  });\n}\n\n/// Helper for \"livedata - no setUserId after unblock\"\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    setUserIdAfterUnblock: function () {\n      this.unblock();\n      var threw = false;\n      var originalUserId = this.userId;\n      try {\n        // Calling setUserId after unblock should throw an error (and not mutate\n        // userId).\n        this.setUserId(originalUserId + \"bla\");\n      } catch (e) {\n        threw = true;\n      }\n      return threw && this.userId === originalUserId;\n    }\n  });\n}\n\n/*****/\n\n/// Helper for \"livedata - overlapping universal subs\"\n\nif (Meteor.isServer) {\n  (function(){\n    var collName = \"overlappingUniversalSubs\";\n    var universalSubscribers = [[], []];\n\n    _.each([0, 1], function (index) {\n      Meteor.publish(null, function () {\n        var sub = this;\n        universalSubscribers[index].push(sub);\n        sub.onStop(function () {\n          universalSubscribers[index] = _.without(\n            universalSubscribers[index], sub);\n        });\n      });\n    });\n\n    Meteor.methods({\n      testOverlappingSubs: function (token) {\n        check(token, String);\n        _.each(universalSubscribers[0], function (sub) {\n          sub.added(collName, token, {});\n        });\n        _.each(universalSubscribers[1], function (sub) {\n          sub.added(collName, token, {});\n        });\n        _.each(universalSubscribers[0], function (sub) {\n          sub.removed(collName, token);\n        });\n      }\n    });\n  })();\n}\n\n/// Helper for \"livedata - runtime universal sub creation\"\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    runtimeUniversalSubCreation: function (token) {\n      check(token, String);\n      Meteor.publish(null, function () {\n        this.added(\"runtimeSubCreation\", token, {});\n      });\n    }\n  });\n}\n\n/// Helper for \"livedata - publisher errors\"\n\nif (Meteor.isServer) {\n  Meteor.publish(\"publisherErrors\", function (collName, options) {\n    check(collName, String);\n    // See below to see what options are accepted.\n    check(options, Object);\n    var sub = this;\n\n    // First add a random item, which should be cleaned up. We use ready/onReady\n    // to make sure that the second test block is only called after the added is\n    // processed, so that there's any chance of the coll.find().count() failing.\n    sub.added(collName, Random.id(), {foo: 42});\n    sub.ready();\n\n    if (options.stopInHandler) {\n      sub.stop();\n      return;\n    }\n\n    var error;\n    if (options.internalError) {\n      error = new Error(\"Egads!\");\n      error.expected = true;  // don't log\n    } else {\n      error = new Meteor.Error(412, \"Explicit error\");\n    }\n    if (options.throwInHandler) {\n      throw error;\n    } else if (options.errorInHandler) {\n      sub.error(error);\n    } else if (options.throwWhenUserIdSet) {\n      if (sub.userId)\n        throw error;\n    } else if (options.errorLater) {\n      Meteor.defer(function () {\n        sub.error(error);\n      });\n    }\n  });\n}\n\n\n/*****/\n\n/// Helpers for \"livedata - publish multiple cursors\"\nOne = new Mongo.Collection(\"collectionOne\");\nTwo = new Mongo.Collection(\"collectionTwo\");\n\nif (Meteor.isServer) {\n  One.remove({});\n  One.insert({name: \"value1\"});\n  One.insert({name: \"value2\"});\n\n  Two.remove({});\n  Two.insert({name: \"value3\"});\n  Two.insert({name: \"value4\"});\n  Two.insert({name: \"value5\"});\n\n  Meteor.publish(\"multiPublish\", function (options) {\n    // See below to see what options are accepted.\n    check(options, Object);\n    if (options.normal) {\n      return [\n        One.find(),\n        Two.find()\n      ];\n    } else if (options.dup) {\n      // Suppress the log of the expected internal error.\n      Meteor._suppress_log(1);\n      return [\n        One.find(),\n        One.find({name: \"value2\"}), // multiple cursors for one collection - error\n        Two.find()\n      ];\n    } else if (options.notCursor) {\n      // Suppress the log of the expected internal error.\n      Meteor._suppress_log(1);\n      return [\n        One.find(),\n        \"not a cursor\",\n        Two.find()\n      ];\n    } else\n      throw \"unexpected options\";\n  });\n}\n\n\n/// Helper for \"livedata - result by value\"\nvar resultByValueArrays = {};\nMeteor.methods({\n  'getArray': function (testId) {\n    if (! _.has(resultByValueArrays, testId))\n      resultByValueArrays[testId] = [];\n    return resultByValueArrays[testId];\n  },\n  'pushToArray': function (testId, value) {\n    if (! _.has(resultByValueArrays, testId))\n      resultByValueArrays[testId] = [];\n    resultByValueArrays[testId].push(value);\n  }\n});\n"]},"hash":"9ed9e0d0aa86dc9edbc0c8227ee2a0d6bb60895c"}
