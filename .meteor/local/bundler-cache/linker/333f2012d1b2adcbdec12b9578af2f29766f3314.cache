[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar EJSON = Package.ejson.EJSON;\nvar DDP = Package['ddp-client'].DDP;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar AllowDeny;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"allow-deny\":{\"allow-deny.js\":function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                               //\n// packages/allow-deny/allow-deny.js                                                                             //\n//                                                                                                               //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                 //\n///                                                                                                              // 1\n/// Remote methods and access control.                                                                           // 2\n///                                                                                                              // 3\n// Restrict default mutators on collection. allow() and deny() take the                                          // 5\n// same options:                                                                                                 // 6\n//                                                                                                               // 7\n// options.insert {Function(userId, doc)}                                                                        // 8\n//   return true to allow/deny adding this document                                                              // 9\n//                                                                                                               // 10\n// options.update {Function(userId, docs, fields, modifier)}                                                     // 11\n//   return true to allow/deny updating these documents.                                                         // 12\n//   `fields` is passed as an array of fields that are to be modified                                            // 13\n//                                                                                                               // 14\n// options.remove {Function(userId, docs)}                                                                       // 15\n//   return true to allow/deny removing these documents                                                          // 16\n//                                                                                                               // 17\n// options.fetch {Array}                                                                                         // 18\n//   Fields to fetch for these validators. If any call to allow or deny                                          // 19\n//   does not have this option then all fields are loaded.                                                       // 20\n//                                                                                                               // 21\n// allow and deny can be called multiple times. The validators are                                               // 22\n// evaluated as follows:                                                                                         // 23\n// - If neither deny() nor allow() has been called on the collection,                                            // 24\n//   then the request is allowed if and only if the \"insecure\" smart                                             // 25\n//   package is in use.                                                                                          // 26\n// - Otherwise, if any deny() function returns true, the request is denied.                                      // 27\n// - Otherwise, if any allow() function returns true, the request is allowed.                                    // 28\n// - Otherwise, the request is denied.                                                                           // 29\n//                                                                                                               // 30\n// Meteor may call your deny() and allow() functions in any order, and may not                                   // 31\n// call all of them if it is able to make a decision without calling them all                                    // 32\n// (so don't include side effects).                                                                              // 33\nAllowDeny = {                                                                                                    // 35\n  CollectionPrototype: {}                                                                                        // 36\n}; // In the `mongo` package, we will extend Mongo.Collection.prototype with these                               // 35\n// methods                                                                                                       // 40\n                                                                                                                 //\nvar CollectionPrototype = AllowDeny.CollectionPrototype; /**                                                     // 41\n                                                          * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n                                                          * @locus Server                                        //\n                                                          * @method allow                                        //\n                                                          * @memberOf Mongo.Collection                           //\n                                                          * @instance                                            //\n                                                          * @param {Object} options                              //\n                                                          * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n                                                          * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n                                                          * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n                                                          */                                                     //\n                                                                                                                 //\nCollectionPrototype.allow = function (options) {                                                                 // 54\n  addValidator(this, 'allow', options);                                                                          // 55\n}; /**                                                                                                           // 56\n    * @summary Override `allow` rules.                                                                           //\n    * @locus Server                                                                                              //\n    * @method deny                                                                                               //\n    * @memberOf Mongo.Collection                                                                                 //\n    * @instance                                                                                                  //\n    * @param {Object} options                                                                                    //\n    * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n    * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n    * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n    */                                                                                                           //\n                                                                                                                 //\nCollectionPrototype.deny = function (options) {                                                                  // 69\n  addValidator(this, 'deny', options);                                                                           // 70\n};                                                                                                               // 71\n                                                                                                                 //\nCollectionPrototype._defineMutationMethods = function (options) {                                                // 73\n  var self = this;                                                                                               // 74\n  options = options || {}; // set to true once we call any allow or deny methods. If true, use                   // 75\n  // allow/deny semantics. If false, use insecure mode semantics.                                                // 78\n                                                                                                                 //\n  self._restricted = false; // Insecure mode (default to allowing writes). Defaults to 'undefined' which         // 79\n  // means insecure iff the insecure package is loaded. This property can be                                     // 82\n  // overriden by tests or packages wishing to change insecure mode behavior of                                  // 83\n  // their collections.                                                                                          // 84\n                                                                                                                 //\n  self._insecure = undefined;                                                                                    // 85\n  self._validators = {                                                                                           // 87\n    insert: {                                                                                                    // 88\n      allow: [],                                                                                                 // 88\n      deny: []                                                                                                   // 88\n    },                                                                                                           // 88\n    update: {                                                                                                    // 89\n      allow: [],                                                                                                 // 89\n      deny: []                                                                                                   // 89\n    },                                                                                                           // 89\n    remove: {                                                                                                    // 90\n      allow: [],                                                                                                 // 90\n      deny: []                                                                                                   // 90\n    },                                                                                                           // 90\n    upsert: {                                                                                                    // 91\n      allow: [],                                                                                                 // 91\n      deny: []                                                                                                   // 91\n    },                                                                                                           // 91\n    // dummy arrays; can't set these!                                                                            // 91\n    fetch: [],                                                                                                   // 92\n    fetchAllFields: false                                                                                        // 93\n  };                                                                                                             // 87\n  if (!self._name) return; // anonymous collection                                                               // 96\n  // XXX Think about method namespacing. Maybe methods should be                                                 // 99\n  // \"Meteor:Mongo:insert/NAME\"?                                                                                 // 100\n                                                                                                                 //\n  self._prefix = '/' + self._name + '/'; // Mutation Methods                                                     // 101\n  // Minimongo on the server gets no stubs; instead, by default                                                  // 104\n  // it wait()s until its result is ready, yielding.                                                             // 105\n  // This matches the behavior of macromongo on the server better.                                               // 106\n  // XXX see #MeteorServerNull                                                                                   // 107\n                                                                                                                 //\n  if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {                             // 108\n    var m = {};                                                                                                  // 109\n                                                                                                                 //\n    _.each(['insert', 'update', 'remove'], function (method) {                                                   // 111\n      var methodName = self._prefix + method;                                                                    // 112\n                                                                                                                 //\n      if (options.useExisting) {                                                                                 // 114\n        var handlerPropName = Meteor.isClient ? '_methodHandlers' : 'method_handlers'; // Do not try to create additional methods if this has already been called.\n        // (Otherwise the .methods() call below will throw an error.)                                            // 117\n                                                                                                                 //\n        if (self._connection[handlerPropName] && typeof self._connection[handlerPropName][methodName] === 'function') return;\n      }                                                                                                          // 120\n                                                                                                                 //\n      m[methodName] = function () /* ... */{                                                                     // 122\n        // All the methods do their own validation, instead of using check().                                    // 123\n        check(arguments, [Match.Any]);                                                                           // 124\n                                                                                                                 //\n        var args = _.toArray(arguments);                                                                         // 125\n                                                                                                                 //\n        try {                                                                                                    // 126\n          // For an insert, if the client didn't specify an _id, generate one                                    // 127\n          // now; because this uses DDP.randomStream, it will be consistent with                                 // 128\n          // what the client generated. We generate it now rather than later so                                  // 129\n          // that if (eg) an allow/deny rule does an insert to the same                                          // 130\n          // collection (not that it really should), the generated _id will                                      // 131\n          // still be the first use of the stream and will be consistent.                                        // 132\n          //                                                                                                     // 133\n          // However, we don't actually stick the _id onto the document yet,                                     // 134\n          // because we want allow/deny rules to be able to differentiate                                        // 135\n          // between arbitrary client-specified _id fields and merely                                            // 136\n          // client-controlled-via-randomSeed fields.                                                            // 137\n          var generatedId = null;                                                                                // 138\n                                                                                                                 //\n          if (method === \"insert\" && !_.has(args[0], '_id')) {                                                   // 139\n            generatedId = self._makeNewID();                                                                     // 140\n          }                                                                                                      // 141\n                                                                                                                 //\n          if (this.isSimulation) {                                                                               // 143\n            // In a client simulation, you can do any mutation (even with a                                      // 144\n            // complex selector).                                                                                // 145\n            if (generatedId !== null) args[0]._id = generatedId;                                                 // 146\n            return self._collection[method].apply(self._collection, args);                                       // 148\n          } // This is the server receiving a method call from the client.                                       // 150\n          // We don't allow arbitrary selectors in mutations from the client: only                               // 154\n          // single-ID selectors.                                                                                // 155\n                                                                                                                 //\n                                                                                                                 //\n          if (method !== 'insert') throwIfSelectorIsNotId(args[0], method);                                      // 156\n                                                                                                                 //\n          if (self._restricted) {                                                                                // 159\n            // short circuit if there is no way it will pass.                                                    // 160\n            if (self._validators[method].allow.length === 0) {                                                   // 161\n              throw new Meteor.Error(403, \"Access denied. No allow validators set on restricted \" + \"collection for method '\" + method + \"'.\");\n            }                                                                                                    // 165\n                                                                                                                 //\n            var validatedMethodName = '_validated' + method.charAt(0).toUpperCase() + method.slice(1);           // 167\n            args.unshift(this.userId);                                                                           // 169\n            method === 'insert' && args.push(generatedId);                                                       // 170\n            return self[validatedMethodName].apply(self, args);                                                  // 171\n          } else if (self._isInsecure()) {                                                                       // 172\n            if (generatedId !== null) args[0]._id = generatedId; // In insecure mode, allow any mutation (with a simple selector).\n            // XXX This is kind of bogus.  Instead of blindly passing whatever                                   // 176\n            //     we get from the network to this function, we should actually                                  // 177\n            //     know the correct arguments for the function and pass just                                     // 178\n            //     them.  For example, if you have an extraneous extra null                                      // 179\n            //     argument and this is Mongo on the server, the .wrapAsync'd                                    // 180\n            //     functions like update will get confused and pass the                                          // 181\n            //     \"fut.resolver()\" in the wrong slot, where _update will never                                  // 182\n            //     invoke it. Bam, broken DDP connection.  Probably should just                                  // 183\n            //     take this whole method and write it three times, invoking                                     // 184\n            //     helpers for the common code.                                                                  // 185\n                                                                                                                 //\n            return self._collection[method].apply(self._collection, args);                                       // 186\n          } else {                                                                                               // 187\n            // In secure mode, if we haven't called allow or deny, then nothing                                  // 188\n            // is permitted.                                                                                     // 189\n            throw new Meteor.Error(403, \"Access denied\");                                                        // 190\n          }                                                                                                      // 191\n        } catch (e) {                                                                                            // 192\n          if (e.name === 'MongoError' || e.name === 'MinimongoError') {                                          // 193\n            throw new Meteor.Error(409, e.toString());                                                           // 194\n          } else {                                                                                               // 195\n            throw e;                                                                                             // 196\n          }                                                                                                      // 197\n        }                                                                                                        // 198\n      };                                                                                                         // 199\n    });                                                                                                          // 200\n                                                                                                                 //\n    self._connection.methods(m);                                                                                 // 202\n  }                                                                                                              // 203\n};                                                                                                               // 204\n                                                                                                                 //\nCollectionPrototype._updateFetch = function (fields) {                                                           // 206\n  var self = this;                                                                                               // 207\n                                                                                                                 //\n  if (!self._validators.fetchAllFields) {                                                                        // 209\n    if (fields) {                                                                                                // 210\n      self._validators.fetch = _.union(self._validators.fetch, fields);                                          // 211\n    } else {                                                                                                     // 212\n      self._validators.fetchAllFields = true; // clear fetch just to make sure we don't accidentally read it     // 213\n                                                                                                                 //\n      self._validators.fetch = null;                                                                             // 215\n    }                                                                                                            // 216\n  }                                                                                                              // 217\n};                                                                                                               // 218\n                                                                                                                 //\nCollectionPrototype._isInsecure = function () {                                                                  // 220\n  var self = this;                                                                                               // 221\n  if (self._insecure === undefined) return !!Package.insecure;                                                   // 222\n  return self._insecure;                                                                                         // 224\n};                                                                                                               // 225\n                                                                                                                 //\nCollectionPrototype._validatedInsert = function (userId, doc, generatedId) {                                     // 227\n  var self = this; // call user validators.                                                                      // 229\n  // Any deny returns true means denied.                                                                         // 232\n                                                                                                                 //\n  if (_.any(self._validators.insert.deny, function (validator) {                                                 // 233\n    return validator(userId, docToValidate(validator, doc, generatedId));                                        // 234\n  })) {                                                                                                          // 235\n    throw new Meteor.Error(403, \"Access denied\");                                                                // 236\n  } // Any allow returns true means proceed. Throw error if they all fail.                                       // 237\n                                                                                                                 //\n                                                                                                                 //\n  if (_.all(self._validators.insert.allow, function (validator) {                                                // 239\n    return !validator(userId, docToValidate(validator, doc, generatedId));                                       // 240\n  })) {                                                                                                          // 241\n    throw new Meteor.Error(403, \"Access denied\");                                                                // 242\n  } // If we generated an ID above, insert it now: after the validation, but                                     // 243\n  // before actually inserting.                                                                                  // 246\n                                                                                                                 //\n                                                                                                                 //\n  if (generatedId !== null) doc._id = generatedId;                                                               // 247\n                                                                                                                 //\n  self._collection.insert.call(self._collection, doc);                                                           // 250\n}; // Simulate a mongo `update` operation while validating that the access                                       // 251\n// control rules set by calls to `allow/deny` are satisfied. If all                                              // 254\n// pass, rewrite the mongo operation to use $in to set the list of                                               // 255\n// document ids to change ##ValidatedChange                                                                      // 256\n                                                                                                                 //\n                                                                                                                 //\nCollectionPrototype._validatedUpdate = function (userId, selector, mutator, options) {                           // 257\n  var self = this;                                                                                               // 259\n  check(mutator, Object);                                                                                        // 261\n  options = _.clone(options) || {};                                                                              // 263\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) throw new Error(\"validated update should be of a single ID\"); // We don't support upserts because they don't fit nicely into allow/deny\n  // rules.                                                                                                      // 269\n                                                                                                                 //\n  if (options.upsert) throw new Meteor.Error(403, \"Access denied. Upserts not \" + \"allowed in a restricted collection.\");\n  var noReplaceError = \"Access denied. In a restricted collection you can only\" + \" update documents, not replace them. Use a Mongo update operator, such \" + \"as '$set'.\"; // compute modified fields\n                                                                                                                 //\n  var fields = [];                                                                                               // 279\n                                                                                                                 //\n  if (_.isEmpty(mutator)) {                                                                                      // 280\n    throw new Meteor.Error(403, noReplaceError);                                                                 // 281\n  }                                                                                                              // 282\n                                                                                                                 //\n  _.each(mutator, function (params, op) {                                                                        // 283\n    if (op.charAt(0) !== '$') {                                                                                  // 284\n      throw new Meteor.Error(403, noReplaceError);                                                               // 285\n    } else if (!_.has(ALLOWED_UPDATE_OPERATIONS, op)) {                                                          // 286\n      throw new Meteor.Error(403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\");\n    } else {                                                                                                     // 289\n      _.each(_.keys(params), function (field) {                                                                  // 290\n        // treat dotted fields as if they are replacing their                                                    // 291\n        // top-level part                                                                                        // 292\n        if (field.indexOf('.') !== -1) field = field.substring(0, field.indexOf('.')); // record the field we are trying to change\n                                                                                                                 //\n        if (!_.contains(fields, field)) fields.push(field);                                                      // 297\n      });                                                                                                        // 299\n    }                                                                                                            // 300\n  });                                                                                                            // 301\n                                                                                                                 //\n  var findOptions = {                                                                                            // 303\n    transform: null                                                                                              // 303\n  };                                                                                                             // 303\n                                                                                                                 //\n  if (!self._validators.fetchAllFields) {                                                                        // 304\n    findOptions.fields = {};                                                                                     // 305\n                                                                                                                 //\n    _.each(self._validators.fetch, function (fieldName) {                                                        // 306\n      findOptions.fields[fieldName] = 1;                                                                         // 307\n    });                                                                                                          // 308\n  }                                                                                                              // 309\n                                                                                                                 //\n  var doc = self._collection.findOne(selector, findOptions);                                                     // 311\n                                                                                                                 //\n  if (!doc) // none satisfied!                                                                                   // 312\n    return 0; // call user validators.                                                                           // 313\n  // Any deny returns true means denied.                                                                         // 316\n                                                                                                                 //\n  if (_.any(self._validators.update.deny, function (validator) {                                                 // 317\n    var factoriedDoc = transformDoc(validator, doc);                                                             // 318\n    return validator(userId, factoriedDoc, fields, mutator);                                                     // 319\n  })) {                                                                                                          // 323\n    throw new Meteor.Error(403, \"Access denied\");                                                                // 324\n  } // Any allow returns true means proceed. Throw error if they all fail.                                       // 325\n                                                                                                                 //\n                                                                                                                 //\n  if (_.all(self._validators.update.allow, function (validator) {                                                // 327\n    var factoriedDoc = transformDoc(validator, doc);                                                             // 328\n    return !validator(userId, factoriedDoc, fields, mutator);                                                    // 329\n  })) {                                                                                                          // 333\n    throw new Meteor.Error(403, \"Access denied\");                                                                // 334\n  }                                                                                                              // 335\n                                                                                                                 //\n  options._forbidReplace = true; // Back when we supported arbitrary client-provided selectors, we actually      // 337\n  // rewrote the selector to include an _id clause before passing to Mongo to                                    // 340\n  // avoid races, but since selector is guaranteed to already just be an ID, we                                  // 341\n  // don't have to any more.                                                                                     // 342\n                                                                                                                 //\n  return self._collection.update.call(self._collection, selector, mutator, options);                             // 344\n}; // Only allow these operations in validated updates. Specifically                                             // 346\n// whitelist operations, rather than blacklist, so new complex                                                   // 349\n// operations that are added aren't automatically allowed. A complex                                             // 350\n// operation is one that does more than just modify its target                                                   // 351\n// field. For now this contains all update operations except '$rename'.                                          // 352\n// http://docs.mongodb.org/manual/reference/operators/#update                                                    // 353\n                                                                                                                 //\n                                                                                                                 //\nvar ALLOWED_UPDATE_OPERATIONS = {                                                                                // 354\n  $inc: 1,                                                                                                       // 355\n  $set: 1,                                                                                                       // 355\n  $unset: 1,                                                                                                     // 355\n  $addToSet: 1,                                                                                                  // 355\n  $pop: 1,                                                                                                       // 355\n  $pullAll: 1,                                                                                                   // 355\n  $pull: 1,                                                                                                      // 355\n  $pushAll: 1,                                                                                                   // 356\n  $push: 1,                                                                                                      // 356\n  $bit: 1                                                                                                        // 356\n}; // Simulate a mongo `remove` operation while validating access control                                        // 354\n// rules. See #ValidatedChange                                                                                   // 360\n                                                                                                                 //\nCollectionPrototype._validatedRemove = function (userId, selector) {                                             // 361\n  var self = this;                                                                                               // 362\n  var findOptions = {                                                                                            // 364\n    transform: null                                                                                              // 364\n  };                                                                                                             // 364\n                                                                                                                 //\n  if (!self._validators.fetchAllFields) {                                                                        // 365\n    findOptions.fields = {};                                                                                     // 366\n                                                                                                                 //\n    _.each(self._validators.fetch, function (fieldName) {                                                        // 367\n      findOptions.fields[fieldName] = 1;                                                                         // 368\n    });                                                                                                          // 369\n  }                                                                                                              // 370\n                                                                                                                 //\n  var doc = self._collection.findOne(selector, findOptions);                                                     // 372\n                                                                                                                 //\n  if (!doc) return 0; // call user validators.                                                                   // 373\n  // Any deny returns true means denied.                                                                         // 377\n                                                                                                                 //\n  if (_.any(self._validators.remove.deny, function (validator) {                                                 // 378\n    return validator(userId, transformDoc(validator, doc));                                                      // 379\n  })) {                                                                                                          // 380\n    throw new Meteor.Error(403, \"Access denied\");                                                                // 381\n  } // Any allow returns true means proceed. Throw error if they all fail.                                       // 382\n                                                                                                                 //\n                                                                                                                 //\n  if (_.all(self._validators.remove.allow, function (validator) {                                                // 384\n    return !validator(userId, transformDoc(validator, doc));                                                     // 385\n  })) {                                                                                                          // 386\n    throw new Meteor.Error(403, \"Access denied\");                                                                // 387\n  } // Back when we supported arbitrary client-provided selectors, we actually                                   // 388\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to                                 // 391\n  // Mongo to avoid races, but since selector is guaranteed to already just be                                   // 392\n  // an ID, we don't have to any more.                                                                           // 393\n                                                                                                                 //\n                                                                                                                 //\n  return self._collection.remove.call(self._collection, selector);                                               // 395\n};                                                                                                               // 396\n                                                                                                                 //\nCollectionPrototype._callMutatorMethod = function () {                                                           // 398\n  function _callMutatorMethod(name, args, callback) {                                                            // 398\n    if (Meteor.isClient && !callback && !alreadyInSimulation()) {                                                // 399\n      // Client can't block, so it can't report errors by exception,                                             // 400\n      // only by callback. If they forget the callback, give them a                                              // 401\n      // default one that logs the error, so they aren't totally                                                 // 402\n      // baffled if their writes don't work because their database is                                            // 403\n      // down.                                                                                                   // 404\n      // Don't give a default callback in simulation, because inside stubs we                                    // 405\n      // want to return the results from the local collection immediately and                                    // 406\n      // not force a callback.                                                                                   // 407\n      callback = function (err) {                                                                                // 408\n        if (err) Meteor._debug(name + \" failed: \" + (err.reason || err.stack));                                  // 409\n      };                                                                                                         // 411\n    } // For two out of three mutator methods, the first argument is a selector                                  // 412\n                                                                                                                 //\n                                                                                                                 //\n    var firstArgIsSelector = name === \"update\" || name === \"remove\";                                             // 415\n                                                                                                                 //\n    if (firstArgIsSelector && !alreadyInSimulation()) {                                                          // 416\n      // If we're about to actually send an RPC, we should throw an error if                                     // 417\n      // this is a non-ID selector, because the mutation methods only allow                                      // 418\n      // single-ID selectors. (If we don't throw here, we'll see flicker.)                                       // 419\n      throwIfSelectorIsNotId(args[0], name);                                                                     // 420\n    }                                                                                                            // 421\n                                                                                                                 //\n    var mutatorMethodName = this._prefix + name;                                                                 // 423\n    return this._connection.apply(mutatorMethodName, args, {                                                     // 424\n      returnStubValue: true                                                                                      // 425\n    }, callback);                                                                                                // 425\n  }                                                                                                              // 426\n                                                                                                                 //\n  return _callMutatorMethod;                                                                                     // 398\n}();                                                                                                             // 398\n                                                                                                                 //\nfunction transformDoc(validator, doc) {                                                                          // 428\n  if (validator.transform) return validator.transform(doc);                                                      // 429\n  return doc;                                                                                                    // 431\n}                                                                                                                // 432\n                                                                                                                 //\nfunction docToValidate(validator, doc, generatedId) {                                                            // 434\n  var ret = doc;                                                                                                 // 435\n                                                                                                                 //\n  if (validator.transform) {                                                                                     // 436\n    ret = EJSON.clone(doc); // If you set a server-side transform on your collection, then you don't get         // 437\n    // to tell the difference between \"client specified the ID\" and \"server                                      // 439\n    // generated the ID\", because transforms expect to get _id.  If you want to                                  // 440\n    // do that check, you can do it with a specific                                                              // 441\n    // `C.allow({insert: f, transform: null})` validator.                                                        // 442\n                                                                                                                 //\n    if (generatedId !== null) {                                                                                  // 443\n      ret._id = generatedId;                                                                                     // 444\n    }                                                                                                            // 445\n                                                                                                                 //\n    ret = validator.transform(ret);                                                                              // 446\n  }                                                                                                              // 447\n                                                                                                                 //\n  return ret;                                                                                                    // 448\n}                                                                                                                // 449\n                                                                                                                 //\nfunction addValidator(collection, allowOrDeny, options) {                                                        // 451\n  // validate keys                                                                                               // 452\n  var VALID_KEYS = ['insert', 'update', 'remove', 'fetch', 'transform'];                                         // 453\n                                                                                                                 //\n  _.each(_.keys(options), function (key) {                                                                       // 454\n    if (!_.contains(VALID_KEYS, key)) throw new Error(allowOrDeny + \": Invalid key: \" + key);                    // 455\n  });                                                                                                            // 457\n                                                                                                                 //\n  collection._restricted = true;                                                                                 // 459\n                                                                                                                 //\n  _.each(['insert', 'update', 'remove'], function (name) {                                                       // 461\n    if (options.hasOwnProperty(name)) {                                                                          // 462\n      if (!(options[name] instanceof Function)) {                                                                // 463\n        throw new Error(allowOrDeny + \": Value for `\" + name + \"` must be a function\");                          // 464\n      } // If the transform is specified at all (including as 'null') in this                                    // 465\n      // call, then take that; otherwise, take the transform from the                                            // 468\n      // collection.                                                                                             // 469\n                                                                                                                 //\n                                                                                                                 //\n      if (options.transform === undefined) {                                                                     // 470\n        options[name].transform = collection._transform; // already wrapped                                      // 471\n      } else {                                                                                                   // 472\n        options[name].transform = LocalCollection.wrapTransform(options.transform);                              // 473\n      }                                                                                                          // 475\n                                                                                                                 //\n      collection._validators[name][allowOrDeny].push(options[name]);                                             // 477\n    }                                                                                                            // 478\n  }); // Only update the fetch fields if we're passed things that affect                                         // 479\n  // fetching. This way allow({}) and allow({insert: f}) don't result in                                         // 482\n  // setting fetchAllFields                                                                                      // 483\n                                                                                                                 //\n                                                                                                                 //\n  if (options.update || options.remove || options.fetch) {                                                       // 484\n    if (options.fetch && !(options.fetch instanceof Array)) {                                                    // 485\n      throw new Error(allowOrDeny + \": Value for `fetch` must be an array\");                                     // 486\n    }                                                                                                            // 487\n                                                                                                                 //\n    collection._updateFetch(options.fetch);                                                                      // 488\n  }                                                                                                              // 489\n}                                                                                                                // 490\n                                                                                                                 //\nfunction throwIfSelectorIsNotId(selector, methodName) {                                                          // 492\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {                                                 // 493\n    throw new Meteor.Error(403, \"Not permitted. Untrusted code may only \" + methodName + \" documents by ID.\");   // 494\n  }                                                                                                              // 497\n}                                                                                                                // 498\n                                                                                                                 //\n; // Determine if we are in a DDP method simulation                                                              // 498\n                                                                                                                 //\nfunction alreadyInSimulation() {                                                                                 // 501\n  var enclosing = DDP._CurrentInvocation.get();                                                                  // 502\n                                                                                                                 //\n  return enclosing && enclosing.isSimulation;                                                                    // 503\n}                                                                                                                // 504\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\"extensions\":[\".js\",\".json\"]});\nrequire(\"./node_modules/meteor/allow-deny/allow-deny.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['allow-deny'] = {}, {\n  AllowDeny: AllowDeny\n});\n\n})();\n","servePath":"/packages/allow-deny.js","sourceMap":{"version":3,"sources":["/packages/allow-deny/allow-deny.js"],"names":["AllowDeny","CollectionPrototype","allow","options","addValidator","deny","_defineMutationMethods","self","_restricted","_insecure","undefined","_validators","insert","update","remove","upsert","fetch","fetchAllFields","_name","_prefix","_connection","Meteor","server","isClient","m","_","each","method","methodName","useExisting","handlerPropName","check","arguments","Match","Any","args","toArray","generatedId","has","_makeNewID","isSimulation","_id","_collection","apply","throwIfSelectorIsNotId","length","Error","validatedMethodName","charAt","toUpperCase","slice","unshift","userId","push","_isInsecure","e","name","toString","methods","_updateFetch","fields","union","Package","insecure","_validatedInsert","doc","any","validator","docToValidate","all","call","_validatedUpdate","selector","mutator","Object","clone","LocalCollection","_selectorIsIdPerhapsAsObject","noReplaceError","isEmpty","params","op","ALLOWED_UPDATE_OPERATIONS","keys","field","indexOf","substring","contains","findOptions","transform","fieldName","findOne","factoriedDoc","transformDoc","_forbidReplace","$inc","$set","$unset","$addToSet","$pop","$pullAll","$pull","$pushAll","$push","$bit","_validatedRemove","_callMutatorMethod","callback","alreadyInSimulation","err","_debug","reason","stack","firstArgIsSelector","mutatorMethodName","returnStubValue","ret","EJSON","collection","allowOrDeny","VALID_KEYS","key","hasOwnProperty","Function","_transform","wrapTransform","Array","enclosing","DDP","_CurrentInvocation","get"],"mappings":"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","file":"/packages/allow-deny.js","sourcesContent":["///\n/// Remote methods and access control.\n///\n\n// Restrict default mutators on collection. allow() and deny() take the\n// same options:\n//\n// options.insert {Function(userId, doc)}\n//   return true to allow/deny adding this document\n//\n// options.update {Function(userId, docs, fields, modifier)}\n//   return true to allow/deny updating these documents.\n//   `fields` is passed as an array of fields that are to be modified\n//\n// options.remove {Function(userId, docs)}\n//   return true to allow/deny removing these documents\n//\n// options.fetch {Array}\n//   Fields to fetch for these validators. If any call to allow or deny\n//   does not have this option then all fields are loaded.\n//\n// allow and deny can be called multiple times. The validators are\n// evaluated as follows:\n// - If neither deny() nor allow() has been called on the collection,\n//   then the request is allowed if and only if the \"insecure\" smart\n//   package is in use.\n// - Otherwise, if any deny() function returns true, the request is denied.\n// - Otherwise, if any allow() function returns true, the request is allowed.\n// - Otherwise, the request is denied.\n//\n// Meteor may call your deny() and allow() functions in any order, and may not\n// call all of them if it is able to make a decision without calling them all\n// (so don't include side effects).\n\nAllowDeny = {\n  CollectionPrototype: {}\n};\n\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these\n// methods\nconst CollectionPrototype = AllowDeny.CollectionPrototype;\n\n/**\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n * @locus Server\n * @method allow\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.allow = function(options) {\n  addValidator(this, 'allow', options);\n};\n\n/**\n * @summary Override `allow` rules.\n * @locus Server\n * @method deny\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.deny = function(options) {\n  addValidator(this, 'deny', options);\n};\n\nCollectionPrototype._defineMutationMethods = function(options) {\n  const self = this;\n  options = options || {};\n\n  // set to true once we call any allow or deny methods. If true, use\n  // allow/deny semantics. If false, use insecure mode semantics.\n  self._restricted = false;\n\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which\n  // means insecure iff the insecure package is loaded. This property can be\n  // overriden by tests or packages wishing to change insecure mode behavior of\n  // their collections.\n  self._insecure = undefined;\n\n  self._validators = {\n    insert: {allow: [], deny: []},\n    update: {allow: [], deny: []},\n    remove: {allow: [], deny: []},\n    upsert: {allow: [], deny: []}, // dummy arrays; can't set these!\n    fetch: [],\n    fetchAllFields: false\n  };\n\n  if (!self._name)\n    return; // anonymous collection\n\n  // XXX Think about method namespacing. Maybe methods should be\n  // \"Meteor:Mongo:insert/NAME\"?\n  self._prefix = '/' + self._name + '/';\n\n  // Mutation Methods\n  // Minimongo on the server gets no stubs; instead, by default\n  // it wait()s until its result is ready, yielding.\n  // This matches the behavior of macromongo on the server better.\n  // XXX see #MeteorServerNull\n  if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {\n    const m = {};\n\n    _.each(['insert', 'update', 'remove'], function (method) {\n      const methodName = self._prefix + method;\n\n      if (options.useExisting) {\n        const handlerPropName = Meteor.isClient ? '_methodHandlers' : 'method_handlers';\n        // Do not try to create additional methods if this has already been called.\n        // (Otherwise the .methods() call below will throw an error.)\n        if (self._connection[handlerPropName] &&\n          typeof self._connection[handlerPropName][methodName] === 'function') return;\n      }\n\n      m[methodName] = function (/* ... */) {\n        // All the methods do their own validation, instead of using check().\n        check(arguments, [Match.Any]);\n        const args = _.toArray(arguments);\n        try {\n          // For an insert, if the client didn't specify an _id, generate one\n          // now; because this uses DDP.randomStream, it will be consistent with\n          // what the client generated. We generate it now rather than later so\n          // that if (eg) an allow/deny rule does an insert to the same\n          // collection (not that it really should), the generated _id will\n          // still be the first use of the stream and will be consistent.\n          //\n          // However, we don't actually stick the _id onto the document yet,\n          // because we want allow/deny rules to be able to differentiate\n          // between arbitrary client-specified _id fields and merely\n          // client-controlled-via-randomSeed fields.\n          let generatedId = null;\n          if (method === \"insert\" && !_.has(args[0], '_id')) {\n            generatedId = self._makeNewID();\n          }\n\n          if (this.isSimulation) {\n            // In a client simulation, you can do any mutation (even with a\n            // complex selector).\n            if (generatedId !== null)\n              args[0]._id = generatedId;\n            return self._collection[method].apply(\n              self._collection, args);\n          }\n\n          // This is the server receiving a method call from the client.\n\n          // We don't allow arbitrary selectors in mutations from the client: only\n          // single-ID selectors.\n          if (method !== 'insert')\n            throwIfSelectorIsNotId(args[0], method);\n\n          if (self._restricted) {\n            // short circuit if there is no way it will pass.\n            if (self._validators[method].allow.length === 0) {\n              throw new Meteor.Error(\n                403, \"Access denied. No allow validators set on restricted \" +\n                  \"collection for method '\" + method + \"'.\");\n            }\n\n            const validatedMethodName =\n                  '_validated' + method.charAt(0).toUpperCase() + method.slice(1);\n            args.unshift(this.userId);\n            method === 'insert' && args.push(generatedId);\n            return self[validatedMethodName].apply(self, args);\n          } else if (self._isInsecure()) {\n            if (generatedId !== null)\n              args[0]._id = generatedId;\n            // In insecure mode, allow any mutation (with a simple selector).\n            // XXX This is kind of bogus.  Instead of blindly passing whatever\n            //     we get from the network to this function, we should actually\n            //     know the correct arguments for the function and pass just\n            //     them.  For example, if you have an extraneous extra null\n            //     argument and this is Mongo on the server, the .wrapAsync'd\n            //     functions like update will get confused and pass the\n            //     \"fut.resolver()\" in the wrong slot, where _update will never\n            //     invoke it. Bam, broken DDP connection.  Probably should just\n            //     take this whole method and write it three times, invoking\n            //     helpers for the common code.\n            return self._collection[method].apply(self._collection, args);\n          } else {\n            // In secure mode, if we haven't called allow or deny, then nothing\n            // is permitted.\n            throw new Meteor.Error(403, \"Access denied\");\n          }\n        } catch (e) {\n          if (e.name === 'MongoError' || e.name === 'MinimongoError') {\n            throw new Meteor.Error(409, e.toString());\n          } else {\n            throw e;\n          }\n        }\n      };\n    });\n\n    self._connection.methods(m);\n  }\n};\n\nCollectionPrototype._updateFetch = function (fields) {\n  const self = this;\n\n  if (!self._validators.fetchAllFields) {\n    if (fields) {\n      self._validators.fetch = _.union(self._validators.fetch, fields);\n    } else {\n      self._validators.fetchAllFields = true;\n      // clear fetch just to make sure we don't accidentally read it\n      self._validators.fetch = null;\n    }\n  }\n};\n\nCollectionPrototype._isInsecure = function () {\n  const self = this;\n  if (self._insecure === undefined)\n    return !!Package.insecure;\n  return self._insecure;\n};\n\nCollectionPrototype._validatedInsert = function (userId, doc,\n                                                         generatedId) {\n  const self = this;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (_.any(self._validators.insert.deny, function(validator) {\n    return validator(userId, docToValidate(validator, doc, generatedId));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (_.all(self._validators.insert.allow, function(validator) {\n    return !validator(userId, docToValidate(validator, doc, generatedId));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // If we generated an ID above, insert it now: after the validation, but\n  // before actually inserting.\n  if (generatedId !== null)\n    doc._id = generatedId;\n\n  self._collection.insert.call(self._collection, doc);\n};\n\n// Simulate a mongo `update` operation while validating that the access\n// control rules set by calls to `allow/deny` are satisfied. If all\n// pass, rewrite the mongo operation to use $in to set the list of\n// document ids to change ##ValidatedChange\nCollectionPrototype._validatedUpdate = function(\n    userId, selector, mutator, options) {\n  const self = this;\n\n  check(mutator, Object);\n\n  options = _.clone(options) || {};\n\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\n    throw new Error(\"validated update should be of a single ID\");\n\n  // We don't support upserts because they don't fit nicely into allow/deny\n  // rules.\n  if (options.upsert)\n    throw new Meteor.Error(403, \"Access denied. Upserts not \" +\n                           \"allowed in a restricted collection.\");\n\n  const noReplaceError = \"Access denied. In a restricted collection you can only\" +\n        \" update documents, not replace them. Use a Mongo update operator, such \" +\n        \"as '$set'.\";\n\n  // compute modified fields\n  const fields = [];\n  if (_.isEmpty(mutator)) {\n    throw new Meteor.Error(403, noReplaceError);\n  }\n  _.each(mutator, function (params, op) {\n    if (op.charAt(0) !== '$') {\n      throw new Meteor.Error(403, noReplaceError);\n    } else if (!_.has(ALLOWED_UPDATE_OPERATIONS, op)) {\n      throw new Meteor.Error(\n        403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\");\n    } else {\n      _.each(_.keys(params), function (field) {\n        // treat dotted fields as if they are replacing their\n        // top-level part\n        if (field.indexOf('.') !== -1)\n          field = field.substring(0, field.indexOf('.'));\n\n        // record the field we are trying to change\n        if (!_.contains(fields, field))\n          fields.push(field);\n      });\n    }\n  });\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    _.each(self._validators.fetch, function(fieldName) {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = self._collection.findOne(selector, findOptions);\n  if (!doc)  // none satisfied!\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (_.any(self._validators.update.deny, function(validator) {\n    const factoriedDoc = transformDoc(validator, doc);\n    return validator(userId,\n                     factoriedDoc,\n                     fields,\n                     mutator);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (_.all(self._validators.update.allow, function(validator) {\n    const factoriedDoc = transformDoc(validator, doc);\n    return !validator(userId,\n                      factoriedDoc,\n                      fields,\n                      mutator);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  options._forbidReplace = true;\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to include an _id clause before passing to Mongo to\n  // avoid races, but since selector is guaranteed to already just be an ID, we\n  // don't have to any more.\n\n  return self._collection.update.call(\n    self._collection, selector, mutator, options);\n};\n\n// Only allow these operations in validated updates. Specifically\n// whitelist operations, rather than blacklist, so new complex\n// operations that are added aren't automatically allowed. A complex\n// operation is one that does more than just modify its target\n// field. For now this contains all update operations except '$rename'.\n// http://docs.mongodb.org/manual/reference/operators/#update\nconst ALLOWED_UPDATE_OPERATIONS = {\n  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,\n  $pushAll:1, $push:1, $bit:1\n};\n\n// Simulate a mongo `remove` operation while validating access control\n// rules. See #ValidatedChange\nCollectionPrototype._validatedRemove = function(userId, selector) {\n  const self = this;\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    _.each(self._validators.fetch, function(fieldName) {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = self._collection.findOne(selector, findOptions);\n  if (!doc)\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (_.any(self._validators.remove.deny, function(validator) {\n    return validator(userId, transformDoc(validator, doc));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (_.all(self._validators.remove.allow, function(validator) {\n    return !validator(userId, transformDoc(validator, doc));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\n  // Mongo to avoid races, but since selector is guaranteed to already just be\n  // an ID, we don't have to any more.\n\n  return self._collection.remove.call(self._collection, selector);\n};\n\nCollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\n  if (Meteor.isClient && !callback && !alreadyInSimulation()) {\n    // Client can't block, so it can't report errors by exception,\n    // only by callback. If they forget the callback, give them a\n    // default one that logs the error, so they aren't totally\n    // baffled if their writes don't work because their database is\n    // down.\n    // Don't give a default callback in simulation, because inside stubs we\n    // want to return the results from the local collection immediately and\n    // not force a callback.\n    callback = function (err) {\n      if (err)\n        Meteor._debug(name + \" failed: \" + (err.reason || err.stack));\n    };\n  }\n\n  // For two out of three mutator methods, the first argument is a selector\n  const firstArgIsSelector = name === \"update\" || name === \"remove\";\n  if (firstArgIsSelector && !alreadyInSimulation()) {\n    // If we're about to actually send an RPC, we should throw an error if\n    // this is a non-ID selector, because the mutation methods only allow\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\n    throwIfSelectorIsNotId(args[0], name);\n  }\n\n  const mutatorMethodName = this._prefix + name;\n  return this._connection.apply(\n    mutatorMethodName, args, { returnStubValue: true }, callback);\n}\n\nfunction transformDoc(validator, doc) {\n  if (validator.transform)\n    return validator.transform(doc);\n  return doc;\n}\n\nfunction docToValidate(validator, doc, generatedId) {\n  let ret = doc;\n  if (validator.transform) {\n    ret = EJSON.clone(doc);\n    // If you set a server-side transform on your collection, then you don't get\n    // to tell the difference between \"client specified the ID\" and \"server\n    // generated the ID\", because transforms expect to get _id.  If you want to\n    // do that check, you can do it with a specific\n    // `C.allow({insert: f, transform: null})` validator.\n    if (generatedId !== null) {\n      ret._id = generatedId;\n    }\n    ret = validator.transform(ret);\n  }\n  return ret;\n}\n\nfunction addValidator(collection, allowOrDeny, options) {\n  // validate keys\n  const VALID_KEYS = ['insert', 'update', 'remove', 'fetch', 'transform'];\n  _.each(_.keys(options), function (key) {\n    if (!_.contains(VALID_KEYS, key))\n      throw new Error(allowOrDeny + \": Invalid key: \" + key);\n  });\n\n  collection._restricted = true;\n\n  _.each(['insert', 'update', 'remove'], function (name) {\n    if (options.hasOwnProperty(name)) {\n      if (!(options[name] instanceof Function)) {\n        throw new Error(allowOrDeny + \": Value for `\" + name + \"` must be a function\");\n      }\n\n      // If the transform is specified at all (including as 'null') in this\n      // call, then take that; otherwise, take the transform from the\n      // collection.\n      if (options.transform === undefined) {\n        options[name].transform = collection._transform;  // already wrapped\n      } else {\n        options[name].transform = LocalCollection.wrapTransform(\n          options.transform);\n      }\n\n      collection._validators[name][allowOrDeny].push(options[name]);\n    }\n  });\n\n  // Only update the fetch fields if we're passed things that affect\n  // fetching. This way allow({}) and allow({insert: f}) don't result in\n  // setting fetchAllFields\n  if (options.update || options.remove || options.fetch) {\n    if (options.fetch && !(options.fetch instanceof Array)) {\n      throw new Error(allowOrDeny + \": Value for `fetch` must be an array\");\n    }\n    collection._updateFetch(options.fetch);\n  }\n}\n\nfunction throwIfSelectorIsNotId(selector, methodName) {\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    throw new Meteor.Error(\n      403, \"Not permitted. Untrusted code may only \" + methodName +\n        \" documents by ID.\");\n  }\n};\n\n// Determine if we are in a DDP method simulation\nfunction alreadyInSimulation() {\n  const enclosing = DDP._CurrentInvocation.get();\n  return enclosing && enclosing.isSimulation;\n}\n"]}}]