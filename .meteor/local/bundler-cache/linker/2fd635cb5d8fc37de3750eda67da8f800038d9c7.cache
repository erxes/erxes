[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar Random = Package.random.Random;\n\n/* Package-scope variables */\nvar RateLimiter;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////\n//                                                                              //\n// packages/rate-limit/rate-limit.js                                            //\n//                                                                              //\n//////////////////////////////////////////////////////////////////////////////////\n                                                                                //\n// Default time interval (in milliseconds) to reset rate limit counters\nvar DEFAULT_INTERVAL_TIME_IN_MILLISECONDS = 1000;\n// Default number of events allowed per time interval\nvar DEFAULT_REQUESTS_PER_INTERVAL = 10;\n\n// A rule is defined by an options object that contains two fields,\n// `numRequestsAllowed` which is the number of events allowed per interval, and\n// an `intervalTime` which is the amount of time in milliseconds before the\n// rate limit restarts its internal counters, and by a matchers object. A\n// matchers object is a POJO that contains a set of keys with values that\n// define the entire set of inputs that match for each key. The values can\n// either be null (optional), a primitive or a function that returns a boolean\n// of whether the provided input's value matches for this key.\n//\n// Rules are uniquely assigned an `id` and they store a dictionary of counters,\n// which are records used to keep track of inputs that match the rule. If a\n// counter reaches the `numRequestsAllowed` within a given `intervalTime`, a\n// rate limit is reached and future inputs that map to that counter will\n// result in errors being returned to the client.\nvar Rule = function (options, matchers) {\n  var self = this;\n\n  self.id = Random.id();\n\n  self.options = options;\n\n  self._matchers = matchers;\n\n  self._lastResetTime = new Date().getTime();\n\n  // Dictionary of input keys to counters\n  self.counters = {};\n};\n\n_.extend(Rule.prototype, {\n  // Determine if this rule applies to the given input by comparing all\n  // rule.matchers. If the match fails, search short circuits instead of\n  // iterating through all matchers.\n  match: function (input) {\n    var self = this;\n    var ruleMatches = true;\n    return _.every(self._matchers, function (matcher, key) {\n      if (matcher !== null) {\n        if (!(_.has(input,key))) {\n          return false;\n        } else {\n          if (typeof matcher === 'function') {\n            if (!(matcher(input[key]))) {\n              return false;\n            }\n          } else {\n            if (matcher !== input[key]) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    });\n  },\n\n  // Generates unique key string for provided input by concatenating all the\n  // keys in the matcher with the corresponding values in the input.\n  // Only called if rule matches input.\n  _generateKeyString: function (input) {\n    var self = this;\n    var returnString = \"\";\n    _.each(self._matchers, function (matcher, key) {\n      if (matcher !== null) {\n        if (typeof matcher === 'function') {\n          if (matcher(input[key])) {\n            returnString += key + input[key];\n          }\n        } else {\n          returnString += key + input[key];\n        }\n      }\n    });\n    return returnString;\n  },\n\n  // Applies the provided input and returns the key string, time since counters\n  // were last reset and time to next reset.\n  apply: function (input) {\n    var self = this;\n    var keyString = self._generateKeyString(input);\n    var timeSinceLastReset = new Date().getTime() - self._lastResetTime;\n    var timeToNextReset = self.options.intervalTime - timeSinceLastReset;\n    return {\n      key: keyString,\n      timeSinceLastReset: timeSinceLastReset,\n      timeToNextReset: timeToNextReset\n    };\n  },\n  // Reset counter dictionary for this specific rule. Called once the\n  // timeSinceLastReset has exceeded the intervalTime. _lastResetTime is\n  // set to be the current time in milliseconds.\n  resetCounter: function () {\n    var self = this;\n\n    // Delete the old counters dictionary to allow for garbage collection\n    self.counters = {};\n    self._lastResetTime = new Date().getTime();\n  },\n  _executeCallback: function (reply, ruleInput) {\n    try {\n      if (this.options.callback) {\n        this.options.callback(reply, ruleInput);\n      }\n    } catch (e) {\n      // Do not throw error here\n      console.error(e);\n    }\n  },\n});\n\n// Initialize rules to be an empty dictionary.\nRateLimiter = function () {\n  var self = this;\n\n  // Dictionary of all rules associated with this RateLimiter, keyed by their\n  // id. Each rule object stores the rule pattern, number of events allowed,\n  // last reset time and the rule reset interval in milliseconds.\n  self.rules = {};\n};\n\n/**\n * Checks if this input has exceeded any rate limits.\n * @param  {object} input dictionary containing key-value pairs of attributes\n * that match to rules\n * @return {object} Returns object of following structure\n * { 'allowed': boolean - is this input allowed\n *   'timeToReset': integer | Infinity - returns time until counters are reset\n *                   in milliseconds\n *   'numInvocationsLeft': integer | Infinity - returns number of calls left\n *   before limit is reached\n * }\n * If multiple rules match, the least number of invocations left is returned.\n * If the rate limit has been reached, the longest timeToReset is returned.\n */\nRateLimiter.prototype.check = function (input) {\n  var self = this;\n  var reply = {\n    allowed: true,\n    timeToReset: 0,\n    numInvocationsLeft: Infinity,\n  };\n\n  var matchedRules = self._findAllMatchingRules(input);\n  _.each(matchedRules, function (rule) {\n    var ruleResult = rule.apply(input);\n    var numInvocations = rule.counters[ruleResult.key];\n\n    if (ruleResult.timeToNextReset < 0) {\n      // Reset all the counters since the rule has reset\n      rule.resetCounter();\n      ruleResult.timeSinceLastReset = new Date().getTime() -\n        rule._lastResetTime;\n      ruleResult.timeToNextReset = rule.options.intervalTime;\n      numInvocations = 0;\n    }\n\n    if (numInvocations > rule.options.numRequestsAllowed) {\n      // Only update timeToReset if the new time would be longer than the\n      // previously set time. This is to ensure that if this input triggers\n      // multiple rules, we return the longest period of time until they can\n      // successfully make another call\n      if (reply.timeToReset < ruleResult.timeToNextReset) {\n        reply.timeToReset = ruleResult.timeToNextReset;\n      };\n      reply.allowed = false;\n      reply.numInvocationsLeft = 0;\n      rule._executeCallback(reply, input);\n    } else {\n      // If this is an allowed attempt and we haven't failed on any of the\n      // other rules that match, update the reply field.\n      if (rule.options.numRequestsAllowed - numInvocations <\n        reply.numInvocationsLeft && reply.allowed) {\n        reply.timeToReset = ruleResult.timeToNextReset;\n        reply.numInvocationsLeft = rule.options.numRequestsAllowed -\n          numInvocations;\n      }\n      rule._executeCallback(reply, input);\n    }\n  });\n  return reply;\n};\n\n/**\n * Adds a rule to dictionary of rules that are checked against on every call.\n * Only inputs that pass all of the rules will be allowed. Returns unique rule\n * id that can be passed to `removeRule`.\n * @param {object} rule    Input dictionary defining certain attributes and\n * rules associated with them.\n * Each attribute's value can either be a value, a function or null. All\n * functions must return a boolean of whether the input is matched by that\n * attribute's rule or not\n * @param {integer} numRequestsAllowed Optional. Number of events allowed per\n * interval. Default = 10.\n * @param {integer} intervalTime Optional. Number of milliseconds before\n * rule's counters are reset. Default = 1000.\n * @param {function} callback Optional. Function to be called after a\n * rule is executed. Two objects will be passed to this function.\n * The first one is the result of RateLimiter.prototype.check\n * The second is the input object of the rule, it has the following structure:\n * {\n *   'type': string - either 'method' or 'subscription'\n *   'name': string - the name of the method or subscription being called\n *   'userId': string - the user ID attempting the method or subscription\n *   'connectionId': string - a string representing the user's DDP connection\n *   'clientAddress': string - the IP address of the user\n * }\n * @return {string} Returns unique rule id\n */\nRateLimiter.prototype.addRule = function (rule, numRequestsAllowed,\n  intervalTime, callback) {\n  var self = this;\n\n  var options = {\n    numRequestsAllowed: numRequestsAllowed || DEFAULT_REQUESTS_PER_INTERVAL,\n    intervalTime: intervalTime || DEFAULT_INTERVAL_TIME_IN_MILLISECONDS,\n    callback: callback && Meteor.bindEnvironment(callback),\n  };\n\n  var newRule = new Rule(options, rule);\n  this.rules[newRule.id] = newRule;\n  return newRule.id;\n};\n\n/**\n * Increment counters in every rule that match to this input\n * @param  {object} input Dictionary object containing attributes that may\n * match to rules\n */\nRateLimiter.prototype.increment = function (input) {\n  var self = this;\n\n  // Only increment rule counters that match this input\n  var matchedRules = self._findAllMatchingRules(input);\n  _.each(matchedRules, function (rule) {\n    var ruleResult = rule.apply(input);\n\n    if (ruleResult.timeSinceLastReset > rule.options.intervalTime) {\n      // Reset all the counters since the rule has reset\n      rule.resetCounter();\n    }\n\n    // Check whether the key exists, incrementing it if so or otherwise\n    // adding the key and setting its value to 1\n    if (_.has(rule.counters, ruleResult.key))\n      rule.counters[ruleResult.key]++;\n    else\n      rule.counters[ruleResult.key] = 1;\n  });\n};\n\n// Returns an array of all rules that apply to provided input\nRateLimiter.prototype._findAllMatchingRules = function (input) {\n  var self = this;\n\n  return _.filter(self.rules, function(rule) {\n    return rule.match(input);\n  });\n};\n/**\n * Provides a mechanism to remove rules from the rate limiter. Returns boolean\n * about success.\n * @param  {string} id Rule id returned from #addRule\n * @return {boolean} Returns true if rule was found and deleted, else false.\n */\nRateLimiter.prototype.removeRule = function (id) {\n  var self = this;\n  if (self.rules[id]) {\n    delete self.rules[id];\n    return true;\n  } else {\n    return false;\n  }\n};\n\n//////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['rate-limit'] = {}, {\n  RateLimiter: RateLimiter\n});\n\n})();\n","servePath":"/packages/rate-limit.js"}]