[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar OrderedDict;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/ordered-dict/ordered_dict.js                                         //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\n// This file defines an ordered dictionary abstraction that is useful for\n// maintaining a dataset backed by observeChanges.  It supports ordering items\n// by specifying the item they now come before.\n\n// The implementation is a dictionary that contains nodes of a doubly-linked\n// list as its values.\n\n// constructs a new element struct\n// next and prev are whole elements, not keys.\nvar element = function (key, value, next, prev) {\n  return {\n    key: key,\n    value: value,\n    next: next,\n    prev: prev\n  };\n};\nOrderedDict = function (/* ... */) {\n  var self = this;\n  self._dict = {};\n  self._first = null;\n  self._last = null;\n  self._size = 0;\n  var args = _.toArray(arguments);\n  self._stringify = function (x) { return x; };\n  if (typeof args[0] === 'function')\n    self._stringify = args.shift();\n  _.each(args, function (kv) {\n    self.putBefore(kv[0], kv[1], null);\n  });\n};\n\n_.extend(OrderedDict.prototype, {\n  // the \"prefix keys with a space\" thing comes from here\n  // https://github.com/documentcloud/underscore/issues/376#issuecomment-2815649\n  _k: function (key) { return \" \" + this._stringify(key); },\n\n  empty: function () {\n    var self = this;\n    return !self._first;\n  },\n  size: function () {\n    var self = this;\n    return self._size;\n  },\n  _linkEltIn: function (elt) {\n    var self = this;\n    if (!elt.next) {\n      elt.prev = self._last;\n      if (self._last)\n        self._last.next = elt;\n      self._last = elt;\n    } else {\n      elt.prev = elt.next.prev;\n      elt.next.prev = elt;\n      if (elt.prev)\n        elt.prev.next = elt;\n    }\n    if (self._first === null || self._first === elt.next)\n      self._first = elt;\n  },\n  _linkEltOut: function (elt) {\n    var self = this;\n    if (elt.next)\n      elt.next.prev = elt.prev;\n    if (elt.prev)\n      elt.prev.next = elt.next;\n    if (elt === self._last)\n      self._last = elt.prev;\n    if (elt === self._first)\n      self._first = elt.next;\n  },\n  putBefore: function (key, item, before) {\n    var self = this;\n    if (self._dict[self._k(key)])\n      throw new Error(\"Item \" + key + \" already present in OrderedDict\");\n    var elt = before ?\n          element(key, item, self._dict[self._k(before)]) :\n          element(key, item, null);\n    if (elt.next === undefined)\n      throw new Error(\"could not find item to put this one before\");\n    self._linkEltIn(elt);\n    self._dict[self._k(key)] = elt;\n    self._size++;\n  },\n  append: function (key, item) {\n    var self = this;\n    self.putBefore(key, item, null);\n  },\n  remove: function (key) {\n    var self = this;\n    var elt = self._dict[self._k(key)];\n    if (elt === undefined)\n      throw new Error(\"Item \" + key + \" not present in OrderedDict\");\n    self._linkEltOut(elt);\n    self._size--;\n    delete self._dict[self._k(key)];\n    return elt.value;\n  },\n  get: function (key) {\n    var self = this;\n    if (self.has(key))\n        return self._dict[self._k(key)].value;\n    return undefined;\n  },\n  has: function (key) {\n    var self = this;\n    return _.has(self._dict, self._k(key));\n  },\n  // Iterate through the items in this dictionary in order, calling\n  // iter(value, key, index) on each one.\n\n  // Stops whenever iter returns OrderedDict.BREAK, or after the last element.\n  forEach: function (iter) {\n    var self = this;\n    var i = 0;\n    var elt = self._first;\n    while (elt !== null) {\n      var b = iter(elt.value, elt.key, i);\n      if (b === OrderedDict.BREAK)\n        return;\n      elt = elt.next;\n      i++;\n    }\n  },\n  first: function () {\n    var self = this;\n    if (self.empty())\n      return undefined;\n    return self._first.key;\n  },\n  firstValue: function () {\n    var self = this;\n    if (self.empty())\n      return undefined;\n    return self._first.value;\n  },\n  last: function () {\n    var self = this;\n    if (self.empty())\n      return undefined;\n    return self._last.key;\n  },\n  lastValue: function () {\n    var self = this;\n    if (self.empty())\n      return undefined;\n    return self._last.value;\n  },\n  prev: function (key) {\n    var self = this;\n    if (self.has(key)) {\n      var elt = self._dict[self._k(key)];\n      if (elt.prev)\n        return elt.prev.key;\n    }\n    return null;\n  },\n  next: function (key) {\n    var self = this;\n    if (self.has(key)) {\n      var elt = self._dict[self._k(key)];\n      if (elt.next)\n        return elt.next.key;\n    }\n    return null;\n  },\n  moveBefore: function (key, before) {\n    var self = this;\n    var elt = self._dict[self._k(key)];\n    var eltBefore = before ? self._dict[self._k(before)] : null;\n    if (elt === undefined)\n      throw new Error(\"Item to move is not present\");\n    if (eltBefore === undefined) {\n      throw new Error(\"Could not find element to move this one before\");\n    }\n    if (eltBefore === elt.next) // no moving necessary\n      return;\n    // remove from its old place\n    self._linkEltOut(elt);\n    // patch into its new place\n    elt.next = eltBefore;\n    self._linkEltIn(elt);\n  },\n  // Linear, sadly.\n  indexOf: function (key) {\n    var self = this;\n    var ret = null;\n    self.forEach(function (v, k, i) {\n      if (self._k(k) === self._k(key)) {\n        ret = i;\n        return OrderedDict.BREAK;\n      }\n      return undefined;\n    });\n    return ret;\n  },\n  _checkRep: function () {\n    var self = this;\n    _.each(self._dict, function (k, v) {\n      if (v.next === v)\n        throw new Error(\"Next is a loop\");\n      if (v.prev === v)\n        throw new Error(\"Prev is a loop\");\n    });\n  }\n\n});\nOrderedDict.BREAK = {\"break\": true};\n\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['ordered-dict'] = {}, {\n  OrderedDict: OrderedDict\n});\n\n})();\n","servePath":"/packages/ordered-dict.js"}]